// This file is @generated by prost-build.
/// Basic identifier types
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicPartition {
    /// Topic name
    #[prost(string, tag = "1")]
    pub topic: ::prost::alloc::string::String,
    /// Partition ID
    #[prost(uint32, tag = "2")]
    pub partition: u32,
}
/// Core message data structure
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Record {
    /// Optional message key
    #[prost(bytes = "bytes", tag = "1")]
    pub key: ::prost::bytes::Bytes,
    /// Message payload
    #[prost(bytes = "bytes", tag = "2")]
    pub value: ::prost::bytes::Bytes,
    /// Message headers
    #[prost(message, repeated, tag = "3")]
    pub headers: ::prost::alloc::vec::Vec<Header>,
    /// Message timestamp
    #[prost(message, optional, tag = "4")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
}
/// Message header key-value pair
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Header {
    /// Header key
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// Header value
    #[prost(bytes = "bytes", tag = "2")]
    pub value: ::prost::bytes::Bytes,
}
/// Write-ahead log record with metadata
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WalRecord {
    /// Target topic and partition
    #[prost(message, optional, tag = "1")]
    pub topic_partition: ::core::option::Option<TopicPartition>,
    /// Record offset
    #[prost(uint64, tag = "2")]
    pub offset: u64,
    /// Actual message record
    #[prost(message, optional, tag = "3")]
    pub record: ::core::option::Option<Record>,
    /// Checksum for integrity
    #[prost(uint32, tag = "4")]
    pub crc32: u32,
    /// WAL record format version
    #[prost(uint32, tag = "5")]
    pub version: u32,
}
/// Broker information and metadata
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrokerInfo {
    /// Unique broker ID
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Broker hostname/IP
    #[prost(string, tag = "2")]
    pub host: ::prost::alloc::string::String,
    /// QUIC server port
    #[prost(uint32, tag = "3")]
    pub port_quic: u32,
    /// gRPC server port
    #[prost(uint32, tag = "4")]
    pub port_rpc: u32,
    /// Rack ID for rack awareness
    #[prost(string, tag = "5")]
    pub rack_id: ::prost::alloc::string::String,
    /// Current broker status
    #[prost(enumeration = "BrokerStatus", tag = "6")]
    pub status: i32,
    /// Broker version for compatibility
    #[prost(uint32, tag = "7")]
    pub version: u32,
}
/// Topic configuration and metadata
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicConfig {
    /// Topic name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Number of partitions
    #[prost(uint32, tag = "2")]
    pub partition_count: u32,
    /// Replication factor
    #[prost(uint32, tag = "3")]
    pub replication_factor: u32,
    /// Retention settings
    #[prost(message, optional, tag = "4")]
    pub retention_policy: ::core::option::Option<RetentionPolicy>,
    /// Compression algorithm
    #[prost(enumeration = "CompressionType", tag = "5")]
    pub compression: i32,
    /// ETL processing modules
    #[prost(string, repeated, tag = "6")]
    pub etl_modules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Configuration version
    #[prost(uint32, tag = "7")]
    pub version: u32,
}
/// Data retention policy configuration
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RetentionPolicy {
    #[prost(oneof = "retention_policy::Policy", tags = "1, 2, 3")]
    pub policy: ::core::option::Option<retention_policy::Policy>,
}
/// Nested message and enum types in `RetentionPolicy`.
pub mod retention_policy {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Policy {
        /// Time-based retention (milliseconds)
        #[prost(int64, tag = "1")]
        RetentionMs(i64),
        /// Size-based retention (bytes)
        #[prost(uint64, tag = "2")]
        RetentionBytes(u64),
        /// Infinite retention
        #[prost(bool, tag = "3")]
        Infinite(bool),
    }
}
/// Partition metadata and state
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionInfo {
    /// Partition ID
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Topic name
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    /// Current leader broker ID
    #[prost(string, tag = "3")]
    pub leader: ::prost::alloc::string::String,
    /// All replica broker IDs
    #[prost(string, repeated, tag = "4")]
    pub replicas: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// In-sync replica broker IDs
    #[prost(string, repeated, tag = "5")]
    pub in_sync_replicas: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Current leader epoch
    #[prost(uint64, tag = "6")]
    pub leader_epoch: u64,
    /// Partition status
    #[prost(enumeration = "PartitionStatus", tag = "7")]
    pub status: i32,
    /// High watermark offset
    #[prost(uint64, tag = "8")]
    pub high_watermark: u64,
    /// Log start offset
    #[prost(uint64, tag = "9")]
    pub log_start_offset: u64,
}
/// Replication result information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplicationResult {
    /// Final offset
    #[prost(uint64, tag = "1")]
    pub offset: u64,
    /// Achieved durability level
    #[prost(enumeration = "DurabilityLevel", tag = "2")]
    pub durability: i32,
    /// Brokers that acknowledged
    #[prost(string, repeated, tag = "3")]
    pub acked_brokers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Number of acknowledgments
    #[prost(uint32, tag = "4")]
    pub ack_count: u32,
}
/// Follower state tracking
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FollowerState {
    /// Follower broker ID
    #[prost(string, tag = "1")]
    pub broker_id: ::prost::alloc::string::String,
    /// Last replicated offset
    #[prost(uint64, tag = "2")]
    pub last_known_offset: u64,
    /// Last heartbeat time
    #[prost(message, optional, tag = "3")]
    pub last_heartbeat: ::core::option::Option<::prost_types::Timestamp>,
    /// Replication lag in messages
    #[prost(uint64, tag = "4")]
    pub lag: u64,
    /// Replication lag in time
    #[prost(uint64, tag = "5")]
    pub lag_time_ms: u64,
    /// Whether follower is in sync
    #[prost(bool, tag = "6")]
    pub in_sync: bool,
}
/// Client request metadata
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestMetadata {
    /// Client identifier
    #[prost(string, tag = "1")]
    pub client_id: ::prost::alloc::string::String,
    /// Request correlation ID
    #[prost(string, tag = "2")]
    pub correlation_id: ::prost::alloc::string::String,
    /// Request timestamp
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// API version
    #[prost(uint32, tag = "4")]
    pub api_version: u32,
    /// Request timeout
    #[prost(uint32, tag = "5")]
    pub timeout_ms: u32,
}
/// Response metadata and status
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseMetadata {
    /// Matching correlation ID
    #[prost(string, tag = "1")]
    pub correlation_id: ::prost::alloc::string::String,
    /// Response timestamp
    #[prost(message, optional, tag = "2")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Error code (0 = success)
    #[prost(uint32, tag = "3")]
    pub error_code: u32,
    /// Human-readable error message
    #[prost(string, tag = "4")]
    pub error_message: ::prost::alloc::string::String,
    /// Client throttle time
    #[prost(uint32, tag = "5")]
    pub throttle_time_ms: u32,
}
/// Cluster metadata information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterMetadata {
    /// Unique cluster identifier
    #[prost(string, tag = "1")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Current controller broker ID
    #[prost(string, tag = "2")]
    pub controller_id: ::prost::alloc::string::String,
    /// All cluster brokers
    #[prost(message, repeated, tag = "3")]
    pub brokers: ::prost::alloc::vec::Vec<BrokerInfo>,
    /// All cluster topics
    #[prost(message, repeated, tag = "4")]
    pub topics: ::prost::alloc::vec::Vec<TopicMetadata>,
    /// Metadata version
    #[prost(uint32, tag = "5")]
    pub version: u32,
    /// Last update timestamp
    #[prost(message, optional, tag = "6")]
    pub last_updated: ::core::option::Option<::prost_types::Timestamp>,
}
/// Topic metadata with partition information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicMetadata {
    /// Topic name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Partition information
    #[prost(message, repeated, tag = "2")]
    pub partitions: ::prost::alloc::vec::Vec<PartitionInfo>,
    /// Topic configuration
    #[prost(message, optional, tag = "3")]
    pub config: ::core::option::Option<TopicConfig>,
    /// Error code for this topic
    #[prost(uint32, tag = "4")]
    pub error_code: u32,
    /// Error message for this topic
    #[prost(string, tag = "5")]
    pub error_message: ::prost::alloc::string::String,
}
/// Generic error information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorInfo {
    /// Numeric error code
    #[prost(uint32, tag = "1")]
    pub code: u32,
    /// Human-readable error message
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Additional error details
    #[prost(string, tag = "3")]
    pub details: ::prost::alloc::string::String,
    /// Whether the error is retryable
    #[prost(bool, tag = "4")]
    pub retryable: bool,
}
/// Performance metrics information
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PerformanceMetrics {
    /// Message throughput
    #[prost(uint64, tag = "1")]
    pub messages_per_second: u64,
    /// Byte throughput
    #[prost(uint64, tag = "2")]
    pub bytes_per_second: u64,
    /// Average latency
    #[prost(double, tag = "3")]
    pub avg_latency_ms: f64,
    /// 99th percentile latency
    #[prost(double, tag = "4")]
    pub p99_latency_ms: f64,
    /// Total messages processed
    #[prost(uint64, tag = "5")]
    pub total_messages: u64,
    /// Total bytes processed
    #[prost(uint64, tag = "6")]
    pub total_bytes: u64,
    /// Total error count
    #[prost(uint64, tag = "7")]
    pub error_count: u64,
    /// Metrics start time
    #[prost(message, optional, tag = "8")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Last update time
    #[prost(message, optional, tag = "9")]
    pub last_updated: ::core::option::Option<::prost_types::Timestamp>,
}
/// Broker status enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BrokerStatus {
    Unknown = 0,
    Online = 1,
    Offline = 2,
    Maintenance = 3,
    Decommissioning = 4,
}
impl BrokerStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "BROKER_STATUS_UNKNOWN",
            Self::Online => "BROKER_STATUS_ONLINE",
            Self::Offline => "BROKER_STATUS_OFFLINE",
            Self::Maintenance => "BROKER_STATUS_MAINTENANCE",
            Self::Decommissioning => "BROKER_STATUS_DECOMMISSIONING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BROKER_STATUS_UNKNOWN" => Some(Self::Unknown),
            "BROKER_STATUS_ONLINE" => Some(Self::Online),
            "BROKER_STATUS_OFFLINE" => Some(Self::Offline),
            "BROKER_STATUS_MAINTENANCE" => Some(Self::Maintenance),
            "BROKER_STATUS_DECOMMISSIONING" => Some(Self::Decommissioning),
            _ => None,
        }
    }
}
/// Compression algorithm enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompressionType {
    None = 0,
    Lz4 = 1,
    Zstd = 2,
}
impl CompressionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "COMPRESSION_TYPE_NONE",
            Self::Lz4 => "COMPRESSION_TYPE_LZ4",
            Self::Zstd => "COMPRESSION_TYPE_ZSTD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMPRESSION_TYPE_NONE" => Some(Self::None),
            "COMPRESSION_TYPE_LZ4" => Some(Self::Lz4),
            "COMPRESSION_TYPE_ZSTD" => Some(Self::Zstd),
            _ => None,
        }
    }
}
/// Partition status enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PartitionStatus {
    Unknown = 0,
    Online = 1,
    Offline = 2,
    UnderReplicated = 3,
    LeaderRecovery = 4,
}
impl PartitionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "PARTITION_STATUS_UNKNOWN",
            Self::Online => "PARTITION_STATUS_ONLINE",
            Self::Offline => "PARTITION_STATUS_OFFLINE",
            Self::UnderReplicated => "PARTITION_STATUS_UNDER_REPLICATED",
            Self::LeaderRecovery => "PARTITION_STATUS_LEADER_RECOVERY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARTITION_STATUS_UNKNOWN" => Some(Self::Unknown),
            "PARTITION_STATUS_ONLINE" => Some(Self::Online),
            "PARTITION_STATUS_OFFLINE" => Some(Self::Offline),
            "PARTITION_STATUS_UNDER_REPLICATED" => Some(Self::UnderReplicated),
            "PARTITION_STATUS_LEADER_RECOVERY" => Some(Self::LeaderRecovery),
            _ => None,
        }
    }
}
/// Message acknowledgment level
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AcknowledgmentLevel {
    /// Fire and forget
    None = 0,
    /// Leader acknowledgment only
    Leader = 1,
    /// Majority of ISR
    Majority = 2,
    /// All ISR members
    All = 3,
    /// Custom acknowledgment count
    Custom = 4,
}
impl AcknowledgmentLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ACKNOWLEDGMENT_LEVEL_NONE",
            Self::Leader => "ACKNOWLEDGMENT_LEVEL_LEADER",
            Self::Majority => "ACKNOWLEDGMENT_LEVEL_MAJORITY",
            Self::All => "ACKNOWLEDGMENT_LEVEL_ALL",
            Self::Custom => "ACKNOWLEDGMENT_LEVEL_CUSTOM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACKNOWLEDGMENT_LEVEL_NONE" => Some(Self::None),
            "ACKNOWLEDGMENT_LEVEL_LEADER" => Some(Self::Leader),
            "ACKNOWLEDGMENT_LEVEL_MAJORITY" => Some(Self::Majority),
            "ACKNOWLEDGMENT_LEVEL_ALL" => Some(Self::All),
            "ACKNOWLEDGMENT_LEVEL_CUSTOM" => Some(Self::Custom),
            _ => None,
        }
    }
}
/// Durability level for writes
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DurabilityLevel {
    /// Local WAL only
    LocalOnly = 0,
    /// Durable to object storage
    Durable = 1,
}
impl DurabilityLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::LocalOnly => "DURABILITY_LEVEL_LOCAL_ONLY",
            Self::Durable => "DURABILITY_LEVEL_DURABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DURABILITY_LEVEL_LOCAL_ONLY" => Some(Self::LocalOnly),
            "DURABILITY_LEVEL_DURABLE" => Some(Self::Durable),
            _ => None,
        }
    }
}
/// Request type enumeration for QUIC protocol
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RequestType {
    Unknown = 0,
    Produce = 1,
    Fetch = 2,
    Metadata = 3,
    Admin = 4,
}
impl RequestType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "REQUEST_TYPE_UNKNOWN",
            Self::Produce => "REQUEST_TYPE_PRODUCE",
            Self::Fetch => "REQUEST_TYPE_FETCH",
            Self::Metadata => "REQUEST_TYPE_METADATA",
            Self::Admin => "REQUEST_TYPE_ADMIN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REQUEST_TYPE_UNKNOWN" => Some(Self::Unknown),
            "REQUEST_TYPE_PRODUCE" => Some(Self::Produce),
            "REQUEST_TYPE_FETCH" => Some(Self::Fetch),
            "REQUEST_TYPE_METADATA" => Some(Self::Metadata),
            "REQUEST_TYPE_ADMIN" => Some(Self::Admin),
            _ => None,
        }
    }
}
/// Common error codes (import from errors.proto for full enum)
/// This is a simplified set for basic usage
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BasicErrorCode {
    /// No error - success
    None = 0,
    /// Unknown error
    Unknown = 1,
    /// Invalid request
    InvalidRequest = 2,
    /// Resource not found
    NotFound = 3,
    /// Operation timeout
    Timeout = 4,
    /// Internal error
    Internal = 5,
}
impl BasicErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "BASIC_ERROR_CODE_NONE",
            Self::Unknown => "BASIC_ERROR_CODE_UNKNOWN",
            Self::InvalidRequest => "BASIC_ERROR_CODE_INVALID_REQUEST",
            Self::NotFound => "BASIC_ERROR_CODE_NOT_FOUND",
            Self::Timeout => "BASIC_ERROR_CODE_TIMEOUT",
            Self::Internal => "BASIC_ERROR_CODE_INTERNAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BASIC_ERROR_CODE_NONE" => Some(Self::None),
            "BASIC_ERROR_CODE_UNKNOWN" => Some(Self::Unknown),
            "BASIC_ERROR_CODE_INVALID_REQUEST" => Some(Self::InvalidRequest),
            "BASIC_ERROR_CODE_NOT_FOUND" => Some(Self::NotFound),
            "BASIC_ERROR_CODE_TIMEOUT" => Some(Self::Timeout),
            "BASIC_ERROR_CODE_INTERNAL" => Some(Self::Internal),
            _ => None,
        }
    }
}
/// Standard error response envelope
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorResponse {
    /// Standardized error code
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub code: i32,
    /// Human-readable error message
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Detailed error information
    #[prost(string, tag = "3")]
    pub details: ::prost::alloc::string::String,
    /// Whether the operation can be retried
    #[prost(bool, tag = "4")]
    pub retryable: bool,
    /// Trace ID for debugging
    #[prost(string, tag = "5")]
    pub trace_id: ::prost::alloc::string::String,
    /// Error occurrence timestamp
    #[prost(message, optional, tag = "6")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Component that generated the error
    #[prost(string, tag = "7")]
    pub component: ::prost::alloc::string::String,
    /// Additional error context
    #[prost(message, repeated, tag = "8")]
    pub context: ::prost::alloc::vec::Vec<ErrorContext>,
    /// Recovery suggestions
    ///
    /// Suggested recovery action
    #[prost(string, tag = "9")]
    pub recovery_suggestion: ::prost::alloc::string::String,
    /// Suggested retry delay
    #[prost(uint32, tag = "10")]
    pub retry_after_ms: u32,
}
/// Error context for debugging and troubleshooting
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorContext {
    /// Context key
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    /// Context value
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    /// Context description
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
}
/// Structured error information with metadata
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StructuredError {
    /// Error code
    #[prost(enumeration = "ErrorCode", tag = "1")]
    pub code: i32,
    /// Error severity
    #[prost(enumeration = "ErrorSeverity", tag = "2")]
    pub severity: i32,
    /// Error category
    #[prost(enumeration = "ErrorCategory", tag = "3")]
    pub category: i32,
    /// Error message
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
    /// Detailed description
    #[prost(string, tag = "5")]
    pub details: ::prost::alloc::string::String,
    /// Error context
    #[prost(message, repeated, tag = "6")]
    pub context: ::prost::alloc::vec::Vec<ErrorContext>,
    /// Occurrence timestamp
    #[prost(message, optional, tag = "7")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Component that generated error
    #[prost(string, tag = "8")]
    pub component: ::prost::alloc::string::String,
    /// Operation that failed
    #[prost(string, tag = "9")]
    pub operation: ::prost::alloc::string::String,
    /// Recovery and retry information
    ///
    /// Whether operation can be retried
    #[prost(bool, tag = "10")]
    pub retryable: bool,
    /// Suggested retry delay
    #[prost(uint32, tag = "11")]
    pub retry_after_ms: u32,
    /// Suggested recovery action
    #[prost(string, tag = "12")]
    pub recovery_action: ::prost::alloc::string::String,
    /// Correlation and tracing
    ///
    /// Distributed trace ID
    #[prost(string, tag = "13")]
    pub trace_id: ::prost::alloc::string::String,
    /// Span ID within trace
    #[prost(string, tag = "14")]
    pub span_id: ::prost::alloc::string::String,
    /// Request correlation ID
    #[prost(string, tag = "15")]
    pub correlation_id: ::prost::alloc::string::String,
    /// Impact assessment
    ///
    /// Resources affected by error
    #[prost(string, repeated, tag = "16")]
    pub affected_resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Description of impact
    #[prost(string, tag = "17")]
    pub impact_description: ::prost::alloc::string::String,
}
/// Warning information for non-fatal issues
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WarningInfo {
    /// Warning code
    #[prost(string, tag = "1")]
    pub code: ::prost::alloc::string::String,
    /// Warning message
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Detailed description
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// Warning timestamp
    #[prost(message, optional, tag = "4")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Component that generated warning
    #[prost(string, tag = "5")]
    pub component: ::prost::alloc::string::String,
    /// Resources affected
    #[prost(string, repeated, tag = "6")]
    pub affected_resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Recommended action
    #[prost(string, tag = "7")]
    pub recommended_action: ::prost::alloc::string::String,
    /// Severity level (1-10)
    #[prost(uint32, tag = "8")]
    pub severity_level: u32,
}
/// Comprehensive error code enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorCode {
    /// Generic success and unknown errors (0-99)
    ///
    /// No error - success
    None = 0,
    /// Unknown/unexpected error
    Unknown = 1,
    /// Internal system error
    InternalError = 2,
    /// Feature not implemented
    NotImplemented = 3,
    /// Deprecated API used
    Deprecated = 4,
    /// Request and validation errors (100-199)
    ///
    /// Invalid request format
    InvalidRequest = 100,
    /// Invalid parameter value
    InvalidParameter = 101,
    /// Required parameter missing
    MissingParameter = 102,
    /// Parameter value out of range
    ParameterOutOfRange = 103,
    /// Invalid message format
    InvalidMessageFormat = 104,
    /// Message exceeds size limit
    MessageTooLarge = 105,
    /// Batch exceeds size limit
    BatchTooLarge = 106,
    /// Invalid data encoding
    InvalidEncoding = 107,
    /// Data checksum validation failed
    ChecksumMismatch = 108,
    /// Protocol violation
    ProtocolError = 109,
    /// Authentication and authorization errors (200-299)
    ///
    /// Authentication failed
    AuthenticationFailed = 200,
    /// Authorization failed
    AuthorizationFailed = 201,
    /// Access denied
    AccessDenied = 202,
    /// Invalid credentials
    InvalidCredentials = 203,
    /// Credentials expired
    CredentialsExpired = 204,
    /// Invalid token
    TokenInvalid = 205,
    /// Token expired
    TokenExpired = 206,
    /// Insufficient permissions
    PermissionDenied = 207,
    /// Quota limit exceeded
    QuotaExceeded = 208,
    /// Rate limit exceeded
    RateLimited = 209,
    /// Resource errors (300-399)
    ///
    /// Resource not found
    ResourceNotFound = 300,
    /// Resource already exists
    ResourceAlreadyExists = 301,
    /// Resource is busy
    ResourceBusy = 302,
    /// Resource exhausted
    ResourceExhausted = 303,
    /// Resource is locked
    ResourceLocked = 304,
    /// Resource is corrupted
    ResourceCorrupted = 305,
    /// Resource temporarily unavailable
    ResourceUnavailable = 306,
    /// Insufficient storage space
    InsufficientStorage = 307,
    /// Disk full
    DiskFull = 308,
    /// Out of memory
    MemoryExhausted = 309,
    /// Topic and partition errors (400-499)
    ///
    /// Topic does not exist
    TopicNotFound = 400,
    /// Topic already exists
    TopicAlreadyExists = 401,
    /// Invalid topic name
    InvalidTopicName = 402,
    /// Partition does not exist
    PartitionNotFound = 403,
    /// Invalid partition ID
    InvalidPartitionId = 404,
    /// Invalid partition count
    InvalidPartitionCount = 405,
    /// Invalid replication factor
    InvalidReplicationFactor = 406,
    /// Partition is offline
    PartitionOffline = 407,
    /// Partition reassignment active
    PartitionReassignmentInProgress = 408,
    /// Topic deletion in progress
    TopicDeletionInProgress = 409,
    /// Leadership and consensus errors (500-599)
    ///
    /// This broker is not the leader
    NotLeader = 500,
    /// Leader is not available
    LeaderNotAvailable = 501,
    /// No leader elected
    NoLeader = 502,
    /// Leader epoch is stale
    StaleLeaderEpoch = 503,
    /// Leader epoch is fenced
    FencedLeaderEpoch = 504,
    /// Unknown leader epoch
    UnknownLeaderEpoch = 505,
    /// Leader election in progress
    ElectionInProgress = 506,
    /// Split brain detected
    SplitBrain = 507,
    /// Quorum lost
    QuorumLoss = 508,
    /// Consensus operation timeout
    ConsensusTimeout = 509,
    /// Replication errors (600-699)
    ///
    /// Replication failed
    ReplicationFailed = 600,
    /// Replica not available
    ReplicaNotAvailable = 601,
    /// Not enough replicas
    NotEnoughReplicas = 602,
    /// Not enough replicas after append
    NotEnoughReplicasAfterAppend = 603,
    /// Replica lag too high
    ReplicaLagTooHigh = 604,
    /// In-sync replica set shrunk
    IsrShrunk = 605,
    /// Replica is out of sync
    OutOfSyncReplica = 606,
    /// Replication timeout
    ReplicationTimeout = 607,
    /// Follower fetch failed
    FollowerFetchFailed = 608,
    /// Leader high watermark stalled
    LeaderHwmStalled = 609,
    /// Offset and data errors (700-799)
    ///
    /// Offset out of range
    OffsetOutOfRange = 700,
    /// Invalid offset value
    InvalidOffset = 701,
    /// Offset not available
    OffsetNotAvailable = 702,
    /// Log has been truncated
    LogTruncated = 703,
    /// Log has been compacted
    LogCompacted = 704,
    /// Record too large
    RecordTooLarge = 705,
    /// Record is corrupted
    RecordCorrupted = 706,
    /// Invalid record format
    InvalidRecordFormat = 707,
    /// Compression/decompression error
    CompressionError = 708,
    /// Serialization/deserialization error
    SerializationError = 709,
    /// Network and connectivity errors (800-899)
    ///
    /// Network communication error
    NetworkError = 800,
    /// Connection failed
    ConnectionFailed = 801,
    /// Connection timeout
    ConnectionTimeout = 802,
    /// Connection refused
    ConnectionRefused = 803,
    /// Connection lost
    ConnectionLost = 804,
    /// DNS resolution failed
    DnsResolutionFailed = 805,
    /// TLS/SSL error
    TlsError = 806,
    /// Certificate error
    CertificateError = 807,
    /// Protocol handshake failed
    HandshakeFailed = 808,
    /// Protocol version mismatch
    ProtocolVersionMismatch = 809,
    /// Broker and cluster errors (900-999)
    ///
    /// Broker not available
    BrokerNotAvailable = 900,
    /// Broker not found
    BrokerNotFound = 901,
    /// Broker is offline
    BrokerOffline = 902,
    /// Broker is overloaded
    BrokerOverloaded = 903,
    /// Cluster unavailable
    ClusterUnavailable = 904,
    /// Controller not available
    ControllerNotAvailable = 905,
    /// This broker is not controller
    NotController = 906,
    /// Controller epoch is stale
    StaleControllerEpoch = 907,
    /// Cluster configuration error
    ClusterConfigurationError = 908,
    /// Metadata update failed
    MetadataUpdateFailed = 909,
    /// Storage and persistence errors (1000-1099)
    ///
    /// Storage system error
    StorageError = 1000,
    /// Write-ahead log error
    WalError = 1001,
    /// WAL corruption detected
    WalCorruption = 1002,
    /// WAL segment not found
    WalSegmentNotFound = 1003,
    /// Object storage error
    ObjectStorageError = 1004,
    /// Object not found in storage
    ObjectNotFound = 1005,
    /// Cache operation error
    CacheError = 1006,
    /// Cache miss
    CacheMiss = 1007,
    /// Cache is full
    CacheFull = 1008,
    /// Flush operation failed
    FlushFailed = 1009,
    /// Sync operation failed
    SyncFailed = 1010,
    /// Backup operation failed
    BackupFailed = 1011,
    /// Restore operation failed
    RestoreFailed = 1012,
    /// Compaction failed
    CompactionFailed = 1013,
    /// Index corruption detected
    IndexCorruption = 1014,
    /// Configuration and management errors (1100-1199)
    ///
    /// Invalid configuration
    InvalidConfiguration = 1100,
    /// Configuration error
    ConfigurationError = 1101,
    /// Configuration update failed
    ConfigurationUpdateFailed = 1102,
    /// Schema validation failed
    SchemaValidationFailed = 1103,
    /// Version mismatch
    VersionMismatch = 1104,
    /// Upgrade in progress
    UpgradeInProgress = 1105,
    /// Downgrade not supported
    DowngradeNotSupported = 1106,
    /// Feature not available
    FeatureNotAvailable = 1107,
    /// License error
    LicenseError = 1108,
    /// System in maintenance mode
    MaintenanceMode = 1109,
    /// ETL and processing errors (1200-1299)
    ///
    /// ETL processing error
    EtlError = 1200,
    /// ETL module not found
    EtlModuleNotFound = 1201,
    /// ETL compilation failed
    EtlCompilationFailed = 1202,
    /// ETL execution failed
    EtlExecutionFailed = 1203,
    /// ETL processing timeout
    EtlTimeout = 1204,
    /// WebAssembly error
    WasmError = 1205,
    /// Sandbox execution error
    SandboxError = 1206,
    /// Resource limit exceeded
    ResourceLimitExceeded = 1207,
    /// Memory limit exceeded
    MemoryLimitExceeded = 1208,
    /// CPU limit exceeded
    CpuLimitExceeded = 1209,
    /// Time limit exceeded
    TimeLimitExceeded = 1210,
    /// Scaling and operations errors (1300-1399)
    ///
    /// Scaling operation error
    ScalingError = 1300,
    /// Rebalancing in progress
    RebalancingInProgress = 1301,
    /// Rebalancing failed
    RebalancingFailed = 1302,
    /// Scale out failed
    ScaleOutFailed = 1303,
    /// Scale in failed
    ScaleInFailed = 1304,
    /// Node addition failed
    NodeAdditionFailed = 1305,
    /// Node removal failed
    NodeRemovalFailed = 1306,
    /// Rolling upgrade failed
    RollingUpgradeFailed = 1307,
    /// Deployment failed
    DeploymentFailed = 1308,
    /// Kubernetes operation error
    KubernetesError = 1309,
    /// Health check failed
    HealthCheckFailed = 1310,
    /// Client and SDK errors (1400-1499)
    ///
    /// Client-side error
    ClientError = 1400,
    /// Invalid client ID
    InvalidClientId = 1401,
    /// Client disconnected
    ClientDisconnected = 1402,
    /// Client request timeout
    ClientTimeout = 1403,
    /// Client quota exceeded
    ClientQuotaExceeded = 1404,
    /// Client session expired
    SessionExpired = 1405,
    /// Invalid session
    InvalidSession = 1406,
    /// Producer is fenced
    ProducerFenced = 1407,
    /// Idempotence error
    IdempotenceError = 1408,
    /// Transaction error
    TransactionError = 1409,
    /// Consumer group error
    ConsumerGroupError = 1410,
    /// Admin and management API errors (1500-1599)
    ///
    /// Admin API error
    AdminApiError = 1500,
    /// Invalid admin operation
    InvalidAdminOperation = 1501,
    /// Admin permission denied
    AdminPermissionDenied = 1502,
    /// Topic creation failed
    TopicCreationFailed = 1503,
    /// Topic deletion failed
    TopicDeletionFailed = 1504,
    /// Partition creation failed
    PartitionCreationFailed = 1505,
    /// ACL creation failed
    AclCreationFailed = 1506,
    /// User creation failed
    UserCreationFailed = 1507,
    /// Quota update failed
    QuotaUpdateFailed = 1508,
    /// Configuration update failed
    ConfigUpdateFailed = 1509,
    /// Metrics unavailable
    MetricsUnavailable = 1510,
}
impl ErrorCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::None => "ERROR_CODE_NONE",
            Self::Unknown => "ERROR_CODE_UNKNOWN",
            Self::InternalError => "ERROR_CODE_INTERNAL_ERROR",
            Self::NotImplemented => "ERROR_CODE_NOT_IMPLEMENTED",
            Self::Deprecated => "ERROR_CODE_DEPRECATED",
            Self::InvalidRequest => "ERROR_CODE_INVALID_REQUEST",
            Self::InvalidParameter => "ERROR_CODE_INVALID_PARAMETER",
            Self::MissingParameter => "ERROR_CODE_MISSING_PARAMETER",
            Self::ParameterOutOfRange => "ERROR_CODE_PARAMETER_OUT_OF_RANGE",
            Self::InvalidMessageFormat => "ERROR_CODE_INVALID_MESSAGE_FORMAT",
            Self::MessageTooLarge => "ERROR_CODE_MESSAGE_TOO_LARGE",
            Self::BatchTooLarge => "ERROR_CODE_BATCH_TOO_LARGE",
            Self::InvalidEncoding => "ERROR_CODE_INVALID_ENCODING",
            Self::ChecksumMismatch => "ERROR_CODE_CHECKSUM_MISMATCH",
            Self::ProtocolError => "ERROR_CODE_PROTOCOL_ERROR",
            Self::AuthenticationFailed => "ERROR_CODE_AUTHENTICATION_FAILED",
            Self::AuthorizationFailed => "ERROR_CODE_AUTHORIZATION_FAILED",
            Self::AccessDenied => "ERROR_CODE_ACCESS_DENIED",
            Self::InvalidCredentials => "ERROR_CODE_INVALID_CREDENTIALS",
            Self::CredentialsExpired => "ERROR_CODE_CREDENTIALS_EXPIRED",
            Self::TokenInvalid => "ERROR_CODE_TOKEN_INVALID",
            Self::TokenExpired => "ERROR_CODE_TOKEN_EXPIRED",
            Self::PermissionDenied => "ERROR_CODE_PERMISSION_DENIED",
            Self::QuotaExceeded => "ERROR_CODE_QUOTA_EXCEEDED",
            Self::RateLimited => "ERROR_CODE_RATE_LIMITED",
            Self::ResourceNotFound => "ERROR_CODE_RESOURCE_NOT_FOUND",
            Self::ResourceAlreadyExists => "ERROR_CODE_RESOURCE_ALREADY_EXISTS",
            Self::ResourceBusy => "ERROR_CODE_RESOURCE_BUSY",
            Self::ResourceExhausted => "ERROR_CODE_RESOURCE_EXHAUSTED",
            Self::ResourceLocked => "ERROR_CODE_RESOURCE_LOCKED",
            Self::ResourceCorrupted => "ERROR_CODE_RESOURCE_CORRUPTED",
            Self::ResourceUnavailable => "ERROR_CODE_RESOURCE_UNAVAILABLE",
            Self::InsufficientStorage => "ERROR_CODE_INSUFFICIENT_STORAGE",
            Self::DiskFull => "ERROR_CODE_DISK_FULL",
            Self::MemoryExhausted => "ERROR_CODE_MEMORY_EXHAUSTED",
            Self::TopicNotFound => "ERROR_CODE_TOPIC_NOT_FOUND",
            Self::TopicAlreadyExists => "ERROR_CODE_TOPIC_ALREADY_EXISTS",
            Self::InvalidTopicName => "ERROR_CODE_INVALID_TOPIC_NAME",
            Self::PartitionNotFound => "ERROR_CODE_PARTITION_NOT_FOUND",
            Self::InvalidPartitionId => "ERROR_CODE_INVALID_PARTITION_ID",
            Self::InvalidPartitionCount => "ERROR_CODE_INVALID_PARTITION_COUNT",
            Self::InvalidReplicationFactor => "ERROR_CODE_INVALID_REPLICATION_FACTOR",
            Self::PartitionOffline => "ERROR_CODE_PARTITION_OFFLINE",
            Self::PartitionReassignmentInProgress => {
                "ERROR_CODE_PARTITION_REASSIGNMENT_IN_PROGRESS"
            }
            Self::TopicDeletionInProgress => "ERROR_CODE_TOPIC_DELETION_IN_PROGRESS",
            Self::NotLeader => "ERROR_CODE_NOT_LEADER",
            Self::LeaderNotAvailable => "ERROR_CODE_LEADER_NOT_AVAILABLE",
            Self::NoLeader => "ERROR_CODE_NO_LEADER",
            Self::StaleLeaderEpoch => "ERROR_CODE_STALE_LEADER_EPOCH",
            Self::FencedLeaderEpoch => "ERROR_CODE_FENCED_LEADER_EPOCH",
            Self::UnknownLeaderEpoch => "ERROR_CODE_UNKNOWN_LEADER_EPOCH",
            Self::ElectionInProgress => "ERROR_CODE_ELECTION_IN_PROGRESS",
            Self::SplitBrain => "ERROR_CODE_SPLIT_BRAIN",
            Self::QuorumLoss => "ERROR_CODE_QUORUM_LOSS",
            Self::ConsensusTimeout => "ERROR_CODE_CONSENSUS_TIMEOUT",
            Self::ReplicationFailed => "ERROR_CODE_REPLICATION_FAILED",
            Self::ReplicaNotAvailable => "ERROR_CODE_REPLICA_NOT_AVAILABLE",
            Self::NotEnoughReplicas => "ERROR_CODE_NOT_ENOUGH_REPLICAS",
            Self::NotEnoughReplicasAfterAppend => {
                "ERROR_CODE_NOT_ENOUGH_REPLICAS_AFTER_APPEND"
            }
            Self::ReplicaLagTooHigh => "ERROR_CODE_REPLICA_LAG_TOO_HIGH",
            Self::IsrShrunk => "ERROR_CODE_ISR_SHRUNK",
            Self::OutOfSyncReplica => "ERROR_CODE_OUT_OF_SYNC_REPLICA",
            Self::ReplicationTimeout => "ERROR_CODE_REPLICATION_TIMEOUT",
            Self::FollowerFetchFailed => "ERROR_CODE_FOLLOWER_FETCH_FAILED",
            Self::LeaderHwmStalled => "ERROR_CODE_LEADER_HWM_STALLED",
            Self::OffsetOutOfRange => "ERROR_CODE_OFFSET_OUT_OF_RANGE",
            Self::InvalidOffset => "ERROR_CODE_INVALID_OFFSET",
            Self::OffsetNotAvailable => "ERROR_CODE_OFFSET_NOT_AVAILABLE",
            Self::LogTruncated => "ERROR_CODE_LOG_TRUNCATED",
            Self::LogCompacted => "ERROR_CODE_LOG_COMPACTED",
            Self::RecordTooLarge => "ERROR_CODE_RECORD_TOO_LARGE",
            Self::RecordCorrupted => "ERROR_CODE_RECORD_CORRUPTED",
            Self::InvalidRecordFormat => "ERROR_CODE_INVALID_RECORD_FORMAT",
            Self::CompressionError => "ERROR_CODE_COMPRESSION_ERROR",
            Self::SerializationError => "ERROR_CODE_SERIALIZATION_ERROR",
            Self::NetworkError => "ERROR_CODE_NETWORK_ERROR",
            Self::ConnectionFailed => "ERROR_CODE_CONNECTION_FAILED",
            Self::ConnectionTimeout => "ERROR_CODE_CONNECTION_TIMEOUT",
            Self::ConnectionRefused => "ERROR_CODE_CONNECTION_REFUSED",
            Self::ConnectionLost => "ERROR_CODE_CONNECTION_LOST",
            Self::DnsResolutionFailed => "ERROR_CODE_DNS_RESOLUTION_FAILED",
            Self::TlsError => "ERROR_CODE_TLS_ERROR",
            Self::CertificateError => "ERROR_CODE_CERTIFICATE_ERROR",
            Self::HandshakeFailed => "ERROR_CODE_HANDSHAKE_FAILED",
            Self::ProtocolVersionMismatch => "ERROR_CODE_PROTOCOL_VERSION_MISMATCH",
            Self::BrokerNotAvailable => "ERROR_CODE_BROKER_NOT_AVAILABLE",
            Self::BrokerNotFound => "ERROR_CODE_BROKER_NOT_FOUND",
            Self::BrokerOffline => "ERROR_CODE_BROKER_OFFLINE",
            Self::BrokerOverloaded => "ERROR_CODE_BROKER_OVERLOADED",
            Self::ClusterUnavailable => "ERROR_CODE_CLUSTER_UNAVAILABLE",
            Self::ControllerNotAvailable => "ERROR_CODE_CONTROLLER_NOT_AVAILABLE",
            Self::NotController => "ERROR_CODE_NOT_CONTROLLER",
            Self::StaleControllerEpoch => "ERROR_CODE_STALE_CONTROLLER_EPOCH",
            Self::ClusterConfigurationError => "ERROR_CODE_CLUSTER_CONFIGURATION_ERROR",
            Self::MetadataUpdateFailed => "ERROR_CODE_METADATA_UPDATE_FAILED",
            Self::StorageError => "ERROR_CODE_STORAGE_ERROR",
            Self::WalError => "ERROR_CODE_WAL_ERROR",
            Self::WalCorruption => "ERROR_CODE_WAL_CORRUPTION",
            Self::WalSegmentNotFound => "ERROR_CODE_WAL_SEGMENT_NOT_FOUND",
            Self::ObjectStorageError => "ERROR_CODE_OBJECT_STORAGE_ERROR",
            Self::ObjectNotFound => "ERROR_CODE_OBJECT_NOT_FOUND",
            Self::CacheError => "ERROR_CODE_CACHE_ERROR",
            Self::CacheMiss => "ERROR_CODE_CACHE_MISS",
            Self::CacheFull => "ERROR_CODE_CACHE_FULL",
            Self::FlushFailed => "ERROR_CODE_FLUSH_FAILED",
            Self::SyncFailed => "ERROR_CODE_SYNC_FAILED",
            Self::BackupFailed => "ERROR_CODE_BACKUP_FAILED",
            Self::RestoreFailed => "ERROR_CODE_RESTORE_FAILED",
            Self::CompactionFailed => "ERROR_CODE_COMPACTION_FAILED",
            Self::IndexCorruption => "ERROR_CODE_INDEX_CORRUPTION",
            Self::InvalidConfiguration => "ERROR_CODE_INVALID_CONFIGURATION",
            Self::ConfigurationError => "ERROR_CODE_CONFIGURATION_ERROR",
            Self::ConfigurationUpdateFailed => "ERROR_CODE_CONFIGURATION_UPDATE_FAILED",
            Self::SchemaValidationFailed => "ERROR_CODE_SCHEMA_VALIDATION_FAILED",
            Self::VersionMismatch => "ERROR_CODE_VERSION_MISMATCH",
            Self::UpgradeInProgress => "ERROR_CODE_UPGRADE_IN_PROGRESS",
            Self::DowngradeNotSupported => "ERROR_CODE_DOWNGRADE_NOT_SUPPORTED",
            Self::FeatureNotAvailable => "ERROR_CODE_FEATURE_NOT_AVAILABLE",
            Self::LicenseError => "ERROR_CODE_LICENSE_ERROR",
            Self::MaintenanceMode => "ERROR_CODE_MAINTENANCE_MODE",
            Self::EtlError => "ERROR_CODE_ETL_ERROR",
            Self::EtlModuleNotFound => "ERROR_CODE_ETL_MODULE_NOT_FOUND",
            Self::EtlCompilationFailed => "ERROR_CODE_ETL_COMPILATION_FAILED",
            Self::EtlExecutionFailed => "ERROR_CODE_ETL_EXECUTION_FAILED",
            Self::EtlTimeout => "ERROR_CODE_ETL_TIMEOUT",
            Self::WasmError => "ERROR_CODE_WASM_ERROR",
            Self::SandboxError => "ERROR_CODE_SANDBOX_ERROR",
            Self::ResourceLimitExceeded => "ERROR_CODE_RESOURCE_LIMIT_EXCEEDED",
            Self::MemoryLimitExceeded => "ERROR_CODE_MEMORY_LIMIT_EXCEEDED",
            Self::CpuLimitExceeded => "ERROR_CODE_CPU_LIMIT_EXCEEDED",
            Self::TimeLimitExceeded => "ERROR_CODE_TIME_LIMIT_EXCEEDED",
            Self::ScalingError => "ERROR_CODE_SCALING_ERROR",
            Self::RebalancingInProgress => "ERROR_CODE_REBALANCING_IN_PROGRESS",
            Self::RebalancingFailed => "ERROR_CODE_REBALANCING_FAILED",
            Self::ScaleOutFailed => "ERROR_CODE_SCALE_OUT_FAILED",
            Self::ScaleInFailed => "ERROR_CODE_SCALE_IN_FAILED",
            Self::NodeAdditionFailed => "ERROR_CODE_NODE_ADDITION_FAILED",
            Self::NodeRemovalFailed => "ERROR_CODE_NODE_REMOVAL_FAILED",
            Self::RollingUpgradeFailed => "ERROR_CODE_ROLLING_UPGRADE_FAILED",
            Self::DeploymentFailed => "ERROR_CODE_DEPLOYMENT_FAILED",
            Self::KubernetesError => "ERROR_CODE_KUBERNETES_ERROR",
            Self::HealthCheckFailed => "ERROR_CODE_HEALTH_CHECK_FAILED",
            Self::ClientError => "ERROR_CODE_CLIENT_ERROR",
            Self::InvalidClientId => "ERROR_CODE_INVALID_CLIENT_ID",
            Self::ClientDisconnected => "ERROR_CODE_CLIENT_DISCONNECTED",
            Self::ClientTimeout => "ERROR_CODE_CLIENT_TIMEOUT",
            Self::ClientQuotaExceeded => "ERROR_CODE_CLIENT_QUOTA_EXCEEDED",
            Self::SessionExpired => "ERROR_CODE_SESSION_EXPIRED",
            Self::InvalidSession => "ERROR_CODE_INVALID_SESSION",
            Self::ProducerFenced => "ERROR_CODE_PRODUCER_FENCED",
            Self::IdempotenceError => "ERROR_CODE_IDEMPOTENCE_ERROR",
            Self::TransactionError => "ERROR_CODE_TRANSACTION_ERROR",
            Self::ConsumerGroupError => "ERROR_CODE_CONSUMER_GROUP_ERROR",
            Self::AdminApiError => "ERROR_CODE_ADMIN_API_ERROR",
            Self::InvalidAdminOperation => "ERROR_CODE_INVALID_ADMIN_OPERATION",
            Self::AdminPermissionDenied => "ERROR_CODE_ADMIN_PERMISSION_DENIED",
            Self::TopicCreationFailed => "ERROR_CODE_TOPIC_CREATION_FAILED",
            Self::TopicDeletionFailed => "ERROR_CODE_TOPIC_DELETION_FAILED",
            Self::PartitionCreationFailed => "ERROR_CODE_PARTITION_CREATION_FAILED",
            Self::AclCreationFailed => "ERROR_CODE_ACL_CREATION_FAILED",
            Self::UserCreationFailed => "ERROR_CODE_USER_CREATION_FAILED",
            Self::QuotaUpdateFailed => "ERROR_CODE_QUOTA_UPDATE_FAILED",
            Self::ConfigUpdateFailed => "ERROR_CODE_CONFIG_UPDATE_FAILED",
            Self::MetricsUnavailable => "ERROR_CODE_METRICS_UNAVAILABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_CODE_NONE" => Some(Self::None),
            "ERROR_CODE_UNKNOWN" => Some(Self::Unknown),
            "ERROR_CODE_INTERNAL_ERROR" => Some(Self::InternalError),
            "ERROR_CODE_NOT_IMPLEMENTED" => Some(Self::NotImplemented),
            "ERROR_CODE_DEPRECATED" => Some(Self::Deprecated),
            "ERROR_CODE_INVALID_REQUEST" => Some(Self::InvalidRequest),
            "ERROR_CODE_INVALID_PARAMETER" => Some(Self::InvalidParameter),
            "ERROR_CODE_MISSING_PARAMETER" => Some(Self::MissingParameter),
            "ERROR_CODE_PARAMETER_OUT_OF_RANGE" => Some(Self::ParameterOutOfRange),
            "ERROR_CODE_INVALID_MESSAGE_FORMAT" => Some(Self::InvalidMessageFormat),
            "ERROR_CODE_MESSAGE_TOO_LARGE" => Some(Self::MessageTooLarge),
            "ERROR_CODE_BATCH_TOO_LARGE" => Some(Self::BatchTooLarge),
            "ERROR_CODE_INVALID_ENCODING" => Some(Self::InvalidEncoding),
            "ERROR_CODE_CHECKSUM_MISMATCH" => Some(Self::ChecksumMismatch),
            "ERROR_CODE_PROTOCOL_ERROR" => Some(Self::ProtocolError),
            "ERROR_CODE_AUTHENTICATION_FAILED" => Some(Self::AuthenticationFailed),
            "ERROR_CODE_AUTHORIZATION_FAILED" => Some(Self::AuthorizationFailed),
            "ERROR_CODE_ACCESS_DENIED" => Some(Self::AccessDenied),
            "ERROR_CODE_INVALID_CREDENTIALS" => Some(Self::InvalidCredentials),
            "ERROR_CODE_CREDENTIALS_EXPIRED" => Some(Self::CredentialsExpired),
            "ERROR_CODE_TOKEN_INVALID" => Some(Self::TokenInvalid),
            "ERROR_CODE_TOKEN_EXPIRED" => Some(Self::TokenExpired),
            "ERROR_CODE_PERMISSION_DENIED" => Some(Self::PermissionDenied),
            "ERROR_CODE_QUOTA_EXCEEDED" => Some(Self::QuotaExceeded),
            "ERROR_CODE_RATE_LIMITED" => Some(Self::RateLimited),
            "ERROR_CODE_RESOURCE_NOT_FOUND" => Some(Self::ResourceNotFound),
            "ERROR_CODE_RESOURCE_ALREADY_EXISTS" => Some(Self::ResourceAlreadyExists),
            "ERROR_CODE_RESOURCE_BUSY" => Some(Self::ResourceBusy),
            "ERROR_CODE_RESOURCE_EXHAUSTED" => Some(Self::ResourceExhausted),
            "ERROR_CODE_RESOURCE_LOCKED" => Some(Self::ResourceLocked),
            "ERROR_CODE_RESOURCE_CORRUPTED" => Some(Self::ResourceCorrupted),
            "ERROR_CODE_RESOURCE_UNAVAILABLE" => Some(Self::ResourceUnavailable),
            "ERROR_CODE_INSUFFICIENT_STORAGE" => Some(Self::InsufficientStorage),
            "ERROR_CODE_DISK_FULL" => Some(Self::DiskFull),
            "ERROR_CODE_MEMORY_EXHAUSTED" => Some(Self::MemoryExhausted),
            "ERROR_CODE_TOPIC_NOT_FOUND" => Some(Self::TopicNotFound),
            "ERROR_CODE_TOPIC_ALREADY_EXISTS" => Some(Self::TopicAlreadyExists),
            "ERROR_CODE_INVALID_TOPIC_NAME" => Some(Self::InvalidTopicName),
            "ERROR_CODE_PARTITION_NOT_FOUND" => Some(Self::PartitionNotFound),
            "ERROR_CODE_INVALID_PARTITION_ID" => Some(Self::InvalidPartitionId),
            "ERROR_CODE_INVALID_PARTITION_COUNT" => Some(Self::InvalidPartitionCount),
            "ERROR_CODE_INVALID_REPLICATION_FACTOR" => {
                Some(Self::InvalidReplicationFactor)
            }
            "ERROR_CODE_PARTITION_OFFLINE" => Some(Self::PartitionOffline),
            "ERROR_CODE_PARTITION_REASSIGNMENT_IN_PROGRESS" => {
                Some(Self::PartitionReassignmentInProgress)
            }
            "ERROR_CODE_TOPIC_DELETION_IN_PROGRESS" => {
                Some(Self::TopicDeletionInProgress)
            }
            "ERROR_CODE_NOT_LEADER" => Some(Self::NotLeader),
            "ERROR_CODE_LEADER_NOT_AVAILABLE" => Some(Self::LeaderNotAvailable),
            "ERROR_CODE_NO_LEADER" => Some(Self::NoLeader),
            "ERROR_CODE_STALE_LEADER_EPOCH" => Some(Self::StaleLeaderEpoch),
            "ERROR_CODE_FENCED_LEADER_EPOCH" => Some(Self::FencedLeaderEpoch),
            "ERROR_CODE_UNKNOWN_LEADER_EPOCH" => Some(Self::UnknownLeaderEpoch),
            "ERROR_CODE_ELECTION_IN_PROGRESS" => Some(Self::ElectionInProgress),
            "ERROR_CODE_SPLIT_BRAIN" => Some(Self::SplitBrain),
            "ERROR_CODE_QUORUM_LOSS" => Some(Self::QuorumLoss),
            "ERROR_CODE_CONSENSUS_TIMEOUT" => Some(Self::ConsensusTimeout),
            "ERROR_CODE_REPLICATION_FAILED" => Some(Self::ReplicationFailed),
            "ERROR_CODE_REPLICA_NOT_AVAILABLE" => Some(Self::ReplicaNotAvailable),
            "ERROR_CODE_NOT_ENOUGH_REPLICAS" => Some(Self::NotEnoughReplicas),
            "ERROR_CODE_NOT_ENOUGH_REPLICAS_AFTER_APPEND" => {
                Some(Self::NotEnoughReplicasAfterAppend)
            }
            "ERROR_CODE_REPLICA_LAG_TOO_HIGH" => Some(Self::ReplicaLagTooHigh),
            "ERROR_CODE_ISR_SHRUNK" => Some(Self::IsrShrunk),
            "ERROR_CODE_OUT_OF_SYNC_REPLICA" => Some(Self::OutOfSyncReplica),
            "ERROR_CODE_REPLICATION_TIMEOUT" => Some(Self::ReplicationTimeout),
            "ERROR_CODE_FOLLOWER_FETCH_FAILED" => Some(Self::FollowerFetchFailed),
            "ERROR_CODE_LEADER_HWM_STALLED" => Some(Self::LeaderHwmStalled),
            "ERROR_CODE_OFFSET_OUT_OF_RANGE" => Some(Self::OffsetOutOfRange),
            "ERROR_CODE_INVALID_OFFSET" => Some(Self::InvalidOffset),
            "ERROR_CODE_OFFSET_NOT_AVAILABLE" => Some(Self::OffsetNotAvailable),
            "ERROR_CODE_LOG_TRUNCATED" => Some(Self::LogTruncated),
            "ERROR_CODE_LOG_COMPACTED" => Some(Self::LogCompacted),
            "ERROR_CODE_RECORD_TOO_LARGE" => Some(Self::RecordTooLarge),
            "ERROR_CODE_RECORD_CORRUPTED" => Some(Self::RecordCorrupted),
            "ERROR_CODE_INVALID_RECORD_FORMAT" => Some(Self::InvalidRecordFormat),
            "ERROR_CODE_COMPRESSION_ERROR" => Some(Self::CompressionError),
            "ERROR_CODE_SERIALIZATION_ERROR" => Some(Self::SerializationError),
            "ERROR_CODE_NETWORK_ERROR" => Some(Self::NetworkError),
            "ERROR_CODE_CONNECTION_FAILED" => Some(Self::ConnectionFailed),
            "ERROR_CODE_CONNECTION_TIMEOUT" => Some(Self::ConnectionTimeout),
            "ERROR_CODE_CONNECTION_REFUSED" => Some(Self::ConnectionRefused),
            "ERROR_CODE_CONNECTION_LOST" => Some(Self::ConnectionLost),
            "ERROR_CODE_DNS_RESOLUTION_FAILED" => Some(Self::DnsResolutionFailed),
            "ERROR_CODE_TLS_ERROR" => Some(Self::TlsError),
            "ERROR_CODE_CERTIFICATE_ERROR" => Some(Self::CertificateError),
            "ERROR_CODE_HANDSHAKE_FAILED" => Some(Self::HandshakeFailed),
            "ERROR_CODE_PROTOCOL_VERSION_MISMATCH" => Some(Self::ProtocolVersionMismatch),
            "ERROR_CODE_BROKER_NOT_AVAILABLE" => Some(Self::BrokerNotAvailable),
            "ERROR_CODE_BROKER_NOT_FOUND" => Some(Self::BrokerNotFound),
            "ERROR_CODE_BROKER_OFFLINE" => Some(Self::BrokerOffline),
            "ERROR_CODE_BROKER_OVERLOADED" => Some(Self::BrokerOverloaded),
            "ERROR_CODE_CLUSTER_UNAVAILABLE" => Some(Self::ClusterUnavailable),
            "ERROR_CODE_CONTROLLER_NOT_AVAILABLE" => Some(Self::ControllerNotAvailable),
            "ERROR_CODE_NOT_CONTROLLER" => Some(Self::NotController),
            "ERROR_CODE_STALE_CONTROLLER_EPOCH" => Some(Self::StaleControllerEpoch),
            "ERROR_CODE_CLUSTER_CONFIGURATION_ERROR" => {
                Some(Self::ClusterConfigurationError)
            }
            "ERROR_CODE_METADATA_UPDATE_FAILED" => Some(Self::MetadataUpdateFailed),
            "ERROR_CODE_STORAGE_ERROR" => Some(Self::StorageError),
            "ERROR_CODE_WAL_ERROR" => Some(Self::WalError),
            "ERROR_CODE_WAL_CORRUPTION" => Some(Self::WalCorruption),
            "ERROR_CODE_WAL_SEGMENT_NOT_FOUND" => Some(Self::WalSegmentNotFound),
            "ERROR_CODE_OBJECT_STORAGE_ERROR" => Some(Self::ObjectStorageError),
            "ERROR_CODE_OBJECT_NOT_FOUND" => Some(Self::ObjectNotFound),
            "ERROR_CODE_CACHE_ERROR" => Some(Self::CacheError),
            "ERROR_CODE_CACHE_MISS" => Some(Self::CacheMiss),
            "ERROR_CODE_CACHE_FULL" => Some(Self::CacheFull),
            "ERROR_CODE_FLUSH_FAILED" => Some(Self::FlushFailed),
            "ERROR_CODE_SYNC_FAILED" => Some(Self::SyncFailed),
            "ERROR_CODE_BACKUP_FAILED" => Some(Self::BackupFailed),
            "ERROR_CODE_RESTORE_FAILED" => Some(Self::RestoreFailed),
            "ERROR_CODE_COMPACTION_FAILED" => Some(Self::CompactionFailed),
            "ERROR_CODE_INDEX_CORRUPTION" => Some(Self::IndexCorruption),
            "ERROR_CODE_INVALID_CONFIGURATION" => Some(Self::InvalidConfiguration),
            "ERROR_CODE_CONFIGURATION_ERROR" => Some(Self::ConfigurationError),
            "ERROR_CODE_CONFIGURATION_UPDATE_FAILED" => {
                Some(Self::ConfigurationUpdateFailed)
            }
            "ERROR_CODE_SCHEMA_VALIDATION_FAILED" => Some(Self::SchemaValidationFailed),
            "ERROR_CODE_VERSION_MISMATCH" => Some(Self::VersionMismatch),
            "ERROR_CODE_UPGRADE_IN_PROGRESS" => Some(Self::UpgradeInProgress),
            "ERROR_CODE_DOWNGRADE_NOT_SUPPORTED" => Some(Self::DowngradeNotSupported),
            "ERROR_CODE_FEATURE_NOT_AVAILABLE" => Some(Self::FeatureNotAvailable),
            "ERROR_CODE_LICENSE_ERROR" => Some(Self::LicenseError),
            "ERROR_CODE_MAINTENANCE_MODE" => Some(Self::MaintenanceMode),
            "ERROR_CODE_ETL_ERROR" => Some(Self::EtlError),
            "ERROR_CODE_ETL_MODULE_NOT_FOUND" => Some(Self::EtlModuleNotFound),
            "ERROR_CODE_ETL_COMPILATION_FAILED" => Some(Self::EtlCompilationFailed),
            "ERROR_CODE_ETL_EXECUTION_FAILED" => Some(Self::EtlExecutionFailed),
            "ERROR_CODE_ETL_TIMEOUT" => Some(Self::EtlTimeout),
            "ERROR_CODE_WASM_ERROR" => Some(Self::WasmError),
            "ERROR_CODE_SANDBOX_ERROR" => Some(Self::SandboxError),
            "ERROR_CODE_RESOURCE_LIMIT_EXCEEDED" => Some(Self::ResourceLimitExceeded),
            "ERROR_CODE_MEMORY_LIMIT_EXCEEDED" => Some(Self::MemoryLimitExceeded),
            "ERROR_CODE_CPU_LIMIT_EXCEEDED" => Some(Self::CpuLimitExceeded),
            "ERROR_CODE_TIME_LIMIT_EXCEEDED" => Some(Self::TimeLimitExceeded),
            "ERROR_CODE_SCALING_ERROR" => Some(Self::ScalingError),
            "ERROR_CODE_REBALANCING_IN_PROGRESS" => Some(Self::RebalancingInProgress),
            "ERROR_CODE_REBALANCING_FAILED" => Some(Self::RebalancingFailed),
            "ERROR_CODE_SCALE_OUT_FAILED" => Some(Self::ScaleOutFailed),
            "ERROR_CODE_SCALE_IN_FAILED" => Some(Self::ScaleInFailed),
            "ERROR_CODE_NODE_ADDITION_FAILED" => Some(Self::NodeAdditionFailed),
            "ERROR_CODE_NODE_REMOVAL_FAILED" => Some(Self::NodeRemovalFailed),
            "ERROR_CODE_ROLLING_UPGRADE_FAILED" => Some(Self::RollingUpgradeFailed),
            "ERROR_CODE_DEPLOYMENT_FAILED" => Some(Self::DeploymentFailed),
            "ERROR_CODE_KUBERNETES_ERROR" => Some(Self::KubernetesError),
            "ERROR_CODE_HEALTH_CHECK_FAILED" => Some(Self::HealthCheckFailed),
            "ERROR_CODE_CLIENT_ERROR" => Some(Self::ClientError),
            "ERROR_CODE_INVALID_CLIENT_ID" => Some(Self::InvalidClientId),
            "ERROR_CODE_CLIENT_DISCONNECTED" => Some(Self::ClientDisconnected),
            "ERROR_CODE_CLIENT_TIMEOUT" => Some(Self::ClientTimeout),
            "ERROR_CODE_CLIENT_QUOTA_EXCEEDED" => Some(Self::ClientQuotaExceeded),
            "ERROR_CODE_SESSION_EXPIRED" => Some(Self::SessionExpired),
            "ERROR_CODE_INVALID_SESSION" => Some(Self::InvalidSession),
            "ERROR_CODE_PRODUCER_FENCED" => Some(Self::ProducerFenced),
            "ERROR_CODE_IDEMPOTENCE_ERROR" => Some(Self::IdempotenceError),
            "ERROR_CODE_TRANSACTION_ERROR" => Some(Self::TransactionError),
            "ERROR_CODE_CONSUMER_GROUP_ERROR" => Some(Self::ConsumerGroupError),
            "ERROR_CODE_ADMIN_API_ERROR" => Some(Self::AdminApiError),
            "ERROR_CODE_INVALID_ADMIN_OPERATION" => Some(Self::InvalidAdminOperation),
            "ERROR_CODE_ADMIN_PERMISSION_DENIED" => Some(Self::AdminPermissionDenied),
            "ERROR_CODE_TOPIC_CREATION_FAILED" => Some(Self::TopicCreationFailed),
            "ERROR_CODE_TOPIC_DELETION_FAILED" => Some(Self::TopicDeletionFailed),
            "ERROR_CODE_PARTITION_CREATION_FAILED" => Some(Self::PartitionCreationFailed),
            "ERROR_CODE_ACL_CREATION_FAILED" => Some(Self::AclCreationFailed),
            "ERROR_CODE_USER_CREATION_FAILED" => Some(Self::UserCreationFailed),
            "ERROR_CODE_QUOTA_UPDATE_FAILED" => Some(Self::QuotaUpdateFailed),
            "ERROR_CODE_CONFIG_UPDATE_FAILED" => Some(Self::ConfigUpdateFailed),
            "ERROR_CODE_METRICS_UNAVAILABLE" => Some(Self::MetricsUnavailable),
            _ => None,
        }
    }
}
/// Error severity levels
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorSeverity {
    Unknown = 0,
    /// Informational
    Info = 1,
    /// Warning - operation may continue
    Warning = 2,
    /// Error - operation failed
    Error = 3,
    /// Critical - system integrity at risk
    Critical = 4,
    /// Fatal - immediate attention required
    Fatal = 5,
}
impl ErrorSeverity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ERROR_SEVERITY_UNKNOWN",
            Self::Info => "ERROR_SEVERITY_INFO",
            Self::Warning => "ERROR_SEVERITY_WARNING",
            Self::Error => "ERROR_SEVERITY_ERROR",
            Self::Critical => "ERROR_SEVERITY_CRITICAL",
            Self::Fatal => "ERROR_SEVERITY_FATAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_SEVERITY_UNKNOWN" => Some(Self::Unknown),
            "ERROR_SEVERITY_INFO" => Some(Self::Info),
            "ERROR_SEVERITY_WARNING" => Some(Self::Warning),
            "ERROR_SEVERITY_ERROR" => Some(Self::Error),
            "ERROR_SEVERITY_CRITICAL" => Some(Self::Critical),
            "ERROR_SEVERITY_FATAL" => Some(Self::Fatal),
            _ => None,
        }
    }
}
/// Error category for classification
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ErrorCategory {
    Unknown = 0,
    /// Temporary/transient error
    Temporary = 1,
    /// Permanent error
    Permanent = 2,
    /// Configuration-related error
    Configuration = 3,
    /// Network-related error
    Network = 4,
    /// Storage-related error
    Storage = 5,
    /// Consensus-related error
    Consensus = 6,
    /// Client-related error
    Client = 7,
    /// Security-related error
    Security = 8,
    /// Resource-related error
    Resource = 9,
    /// Operational error
    Operational = 10,
}
impl ErrorCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ERROR_CATEGORY_UNKNOWN",
            Self::Temporary => "ERROR_CATEGORY_TEMPORARY",
            Self::Permanent => "ERROR_CATEGORY_PERMANENT",
            Self::Configuration => "ERROR_CATEGORY_CONFIGURATION",
            Self::Network => "ERROR_CATEGORY_NETWORK",
            Self::Storage => "ERROR_CATEGORY_STORAGE",
            Self::Consensus => "ERROR_CATEGORY_CONSENSUS",
            Self::Client => "ERROR_CATEGORY_CLIENT",
            Self::Security => "ERROR_CATEGORY_SECURITY",
            Self::Resource => "ERROR_CATEGORY_RESOURCE",
            Self::Operational => "ERROR_CATEGORY_OPERATIONAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ERROR_CATEGORY_UNKNOWN" => Some(Self::Unknown),
            "ERROR_CATEGORY_TEMPORARY" => Some(Self::Temporary),
            "ERROR_CATEGORY_PERMANENT" => Some(Self::Permanent),
            "ERROR_CATEGORY_CONFIGURATION" => Some(Self::Configuration),
            "ERROR_CATEGORY_NETWORK" => Some(Self::Network),
            "ERROR_CATEGORY_STORAGE" => Some(Self::Storage),
            "ERROR_CATEGORY_CONSENSUS" => Some(Self::Consensus),
            "ERROR_CATEGORY_CLIENT" => Some(Self::Client),
            "ERROR_CATEGORY_SECURITY" => Some(Self::Security),
            "ERROR_CATEGORY_RESOURCE" => Some(Self::Resource),
            "ERROR_CATEGORY_OPERATIONAL" => Some(Self::Operational),
            _ => None,
        }
    }
}
/// Extended cluster metadata with operational information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtendedClusterMetadata {
    /// Unique cluster identifier
    #[prost(string, tag = "1")]
    pub cluster_id: ::prost::alloc::string::String,
    /// Metadata version for consistency
    #[prost(uint64, tag = "2")]
    pub metadata_version: u64,
    /// Last metadata update time
    #[prost(message, optional, tag = "3")]
    pub last_updated: ::core::option::Option<::prost_types::Timestamp>,
    /// Current controller broker ID
    #[prost(string, tag = "4")]
    pub controller_id: ::prost::alloc::string::String,
    /// Controller epoch
    #[prost(uint64, tag = "5")]
    pub controller_epoch: u64,
    /// Cluster members and topology
    ///
    /// All cluster brokers
    #[prost(message, repeated, tag = "6")]
    pub brokers: ::prost::alloc::vec::Vec<BrokerMetadata>,
    /// All cluster topics
    #[prost(message, repeated, tag = "7")]
    pub topics: ::prost::alloc::vec::Vec<ExtendedTopicMetadata>,
    /// Cluster configuration
    #[prost(message, optional, tag = "8")]
    pub configuration: ::core::option::Option<ClusterConfiguration>,
    /// Operational state
    ///
    /// Cluster health status
    #[prost(message, optional, tag = "9")]
    pub health: ::core::option::Option<ClusterHealth>,
    /// Active operations
    #[prost(message, repeated, tag = "10")]
    pub ongoing_operations: ::prost::alloc::vec::Vec<OngoingOperation>,
    /// Performance and capacity information
    ///
    /// Cluster capacity metrics
    #[prost(message, optional, tag = "11")]
    pub capacity: ::core::option::Option<ClusterCapacity>,
    /// Cluster performance metrics
    #[prost(message, optional, tag = "12")]
    pub performance: ::core::option::Option<ClusterPerformance>,
}
/// Extended broker metadata with operational information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrokerMetadata {
    /// Broker ID
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Broker hostname/IP
    #[prost(string, tag = "2")]
    pub host: ::prost::alloc::string::String,
    /// QUIC server port
    #[prost(uint32, tag = "3")]
    pub port_quic: u32,
    /// gRPC server port
    #[prost(uint32, tag = "4")]
    pub port_rpc: u32,
    /// Rack ID for rack awareness
    #[prost(string, tag = "5")]
    pub rack_id: ::prost::alloc::string::String,
    /// Availability zone ID
    #[prost(string, tag = "6")]
    pub zone_id: ::prost::alloc::string::String,
    /// Region ID
    #[prost(string, tag = "7")]
    pub region_id: ::prost::alloc::string::String,
    /// Broker state and health
    ///
    /// Current broker status
    #[prost(enumeration = "BrokerStatus", tag = "8")]
    pub status: i32,
    /// Broker health information
    #[prost(message, optional, tag = "9")]
    pub health: ::core::option::Option<BrokerHealth>,
    /// Last heartbeat timestamp
    #[prost(message, optional, tag = "10")]
    pub last_heartbeat: ::core::option::Option<::prost_types::Timestamp>,
    /// Broker startup time
    #[prost(message, optional, tag = "11")]
    pub startup_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Capabilities and configuration
    ///
    /// Broker software version
    #[prost(string, tag = "12")]
    pub version: ::prost::alloc::string::String,
    /// Supported capabilities
    #[prost(string, repeated, tag = "13")]
    pub capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Broker configuration
    #[prost(message, optional, tag = "14")]
    pub configuration: ::core::option::Option<BrokerConfiguration>,
    /// Resource and performance information
    ///
    /// Resource allocation
    #[prost(message, optional, tag = "15")]
    pub resources: ::core::option::Option<BrokerResources>,
    /// Performance metrics
    #[prost(message, optional, tag = "16")]
    pub performance: ::core::option::Option<BrokerPerformance>,
    /// Assigned topic:partition IDs
    #[prost(string, repeated, tag = "17")]
    pub assigned_partitions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Partitions where this broker is leader
    #[prost(string, repeated, tag = "18")]
    pub leadership_partitions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Network and connectivity
    ///
    /// All network endpoints
    #[prost(message, repeated, tag = "19")]
    pub endpoints: ::prost::alloc::vec::Vec<NetworkEndpoint>,
    /// Network health status
    #[prost(message, optional, tag = "20")]
    pub network_health: ::core::option::Option<NetworkHealth>,
}
/// Extended topic metadata with operational information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtendedTopicMetadata {
    /// Topic name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Topic configuration
    #[prost(message, optional, tag = "2")]
    pub configuration: ::core::option::Option<TopicConfiguration>,
    /// Current topic status
    #[prost(enumeration = "TopicStatus", tag = "3")]
    pub status: i32,
    /// Topic creation time
    #[prost(message, optional, tag = "4")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Last modification time
    #[prost(message, optional, tag = "5")]
    pub last_modified: ::core::option::Option<::prost_types::Timestamp>,
    /// Partition information
    ///
    /// Detailed partition metadata
    #[prost(message, repeated, tag = "6")]
    pub partitions: ::prost::alloc::vec::Vec<PartitionMetadata>,
    /// Partition distribution strategy
    #[prost(message, optional, tag = "7")]
    pub distribution: ::core::option::Option<PartitionDistribution>,
    /// Performance and usage metrics
    ///
    /// Topic performance metrics
    #[prost(message, optional, tag = "8")]
    pub performance: ::core::option::Option<TopicPerformance>,
    /// Topic usage statistics
    #[prost(message, optional, tag = "9")]
    pub usage: ::core::option::Option<TopicUsage>,
    /// Data management
    ///
    /// Data retention information
    #[prost(message, optional, tag = "10")]
    pub retention: ::core::option::Option<DataRetention>,
    /// Data compaction status
    #[prost(message, optional, tag = "11")]
    pub compaction: ::core::option::Option<DataCompaction>,
    /// Access control and security
    ///
    /// Access control rules
    #[prost(message, repeated, tag = "12")]
    pub access_controls: ::prost::alloc::vec::Vec<AccessControl>,
    /// Encryption status
    #[prost(message, optional, tag = "13")]
    pub encryption: ::core::option::Option<EncryptionStatus>,
}
/// Detailed partition metadata with operational state
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionMetadata {
    /// Partition ID
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Topic name
    #[prost(string, tag = "2")]
    pub topic: ::prost::alloc::string::String,
    /// Current leader broker ID
    #[prost(string, tag = "3")]
    pub leader: ::prost::alloc::string::String,
    /// All replica broker IDs
    #[prost(string, repeated, tag = "4")]
    pub replicas: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// In-sync replica broker IDs
    #[prost(string, repeated, tag = "5")]
    pub in_sync_replicas: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Current leader epoch
    #[prost(uint64, tag = "6")]
    pub leader_epoch: u64,
    /// Operational state
    ///
    /// Partition status
    #[prost(enumeration = "PartitionStatus", tag = "7")]
    pub status: i32,
    /// Partition health
    #[prost(message, optional, tag = "8")]
    pub health: ::core::option::Option<PartitionHealth>,
    /// Last leadership change
    #[prost(message, optional, tag = "9")]
    pub last_leader_change: ::core::option::Option<::prost_types::Timestamp>,
    /// Data state
    ///
    /// High watermark offset
    #[prost(uint64, tag = "10")]
    pub high_watermark: u64,
    /// Log start offset
    #[prost(uint64, tag = "11")]
    pub log_start_offset: u64,
    /// Log end offset
    #[prost(uint64, tag = "12")]
    pub log_end_offset: u64,
    /// Partition size in bytes
    #[prost(uint64, tag = "13")]
    pub size_bytes: u64,
    /// Number of log segments
    #[prost(uint32, tag = "14")]
    pub segment_count: u32,
    /// Performance metrics
    ///
    /// Partition performance
    #[prost(message, optional, tag = "15")]
    pub performance: ::core::option::Option<PartitionPerformance>,
    /// Per-replica metadata
    #[prost(message, repeated, tag = "16")]
    pub replica_metadata: ::prost::alloc::vec::Vec<ReplicaMetadata>,
    /// Replication state
    ///
    /// Replication state
    #[prost(message, optional, tag = "17")]
    pub replication: ::core::option::Option<ReplicationState>,
}
/// Per-replica metadata and state
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReplicaMetadata {
    /// Replica broker ID
    #[prost(string, tag = "1")]
    pub broker_id: ::prost::alloc::string::String,
    /// Replica role
    #[prost(enumeration = "ReplicaRole", tag = "2")]
    pub role: i32,
    /// Replica status
    #[prost(enumeration = "ReplicaStatus", tag = "3")]
    pub status: i32,
    /// Replica log end offset
    #[prost(uint64, tag = "4")]
    pub log_end_offset: u64,
    /// Replica high watermark
    #[prost(uint64, tag = "5")]
    pub high_watermark: u64,
    /// Lag in messages
    #[prost(uint64, tag = "6")]
    pub lag_messages: u64,
    /// Lag in milliseconds
    #[prost(uint64, tag = "7")]
    pub lag_time_ms: u64,
    /// Last fetch timestamp
    #[prost(message, optional, tag = "8")]
    pub last_fetch: ::core::option::Option<::prost_types::Timestamp>,
    /// Fetch rate MB/s
    #[prost(double, tag = "9")]
    pub fetch_rate_mbs: f64,
    /// Recent error count
    #[prost(uint32, tag = "10")]
    pub error_count: u32,
}
/// Replication state information
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReplicationState {
    /// ISR version number
    #[prost(uint64, tag = "1")]
    pub isr_version: u64,
    /// Maximum lag in messages
    #[prost(uint64, tag = "2")]
    pub max_lag_messages: u64,
    /// Maximum lag in time
    #[prost(uint64, tag = "3")]
    pub max_lag_time_ms: u64,
    /// Average replication latency
    #[prost(double, tag = "4")]
    pub average_replication_latency_ms: f64,
    /// Number of under-replicated partitions
    #[prost(uint32, tag = "5")]
    pub under_replicated_count: u32,
    /// Last ISR change timestamp
    #[prost(message, optional, tag = "6")]
    pub last_isr_change: ::core::option::Option<::prost_types::Timestamp>,
    /// Performance metrics
    ///
    /// Replication throughput
    #[prost(double, tag = "7")]
    pub replication_throughput_mbs: f64,
    /// Total bytes replicated
    #[prost(uint64, tag = "8")]
    pub total_replicated_bytes: u64,
    /// Total messages replicated
    #[prost(uint64, tag = "9")]
    pub total_replicated_messages: u64,
}
/// Cluster configuration settings
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterConfiguration {
    /// Cluster name
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Cluster description
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    /// Minimum broker count
    #[prost(uint32, tag = "3")]
    pub min_broker_count: u32,
    /// Maximum broker count
    #[prost(uint32, tag = "4")]
    pub max_broker_count: u32,
    /// Default replication factor
    #[prost(uint32, tag = "5")]
    pub default_replication_factor: u32,
    /// Minimum ISR count
    #[prost(uint32, tag = "6")]
    pub min_in_sync_replicas: u32,
    /// Timing configurations
    ///
    /// Controller election timeout
    #[prost(uint32, tag = "7")]
    pub controller_election_timeout_ms: u32,
    /// Broker heartbeat interval
    #[prost(uint32, tag = "8")]
    pub broker_heartbeat_interval_ms: u32,
    /// Session timeout
    #[prost(uint32, tag = "9")]
    pub session_timeout_ms: u32,
    /// Request timeout
    #[prost(uint32, tag = "10")]
    pub request_timeout_ms: u32,
    /// Data retention defaults
    ///
    /// Default retention time
    #[prost(uint64, tag = "11")]
    pub default_retention_ms: u64,
    /// Default retention size
    #[prost(uint64, tag = "12")]
    pub default_retention_bytes: u64,
    /// Default segment size
    #[prost(uint32, tag = "13")]
    pub default_segment_size_mb: u32,
    /// Performance configurations
    ///
    /// Maximum batch size
    #[prost(uint32, tag = "14")]
    pub max_batch_size_bytes: u32,
    /// Maximum request size
    #[prost(uint32, tag = "15")]
    pub max_request_size_bytes: u32,
    /// Producer buffer memory
    #[prost(uint32, tag = "16")]
    pub producer_buffer_memory_bytes: u32,
    /// Consumer fetch max bytes
    #[prost(uint32, tag = "17")]
    pub consumer_fetch_max_bytes: u32,
    /// Security configurations
    ///
    /// Authentication enabled
    #[prost(bool, tag = "18")]
    pub authentication_enabled: bool,
    /// Authorization enabled
    #[prost(bool, tag = "19")]
    pub authorization_enabled: bool,
    /// Encryption in transit
    #[prost(bool, tag = "20")]
    pub encryption_in_transit: bool,
    /// Encryption at rest
    #[prost(bool, tag = "21")]
    pub encryption_at_rest: bool,
    /// Operational configurations
    ///
    /// Auto create topics
    #[prost(bool, tag = "22")]
    pub auto_create_topics: bool,
    /// Auto leader rebalance
    #[prost(bool, tag = "23")]
    pub auto_leader_rebalance: bool,
    /// Leader imbalance threshold
    #[prost(uint32, tag = "24")]
    pub leader_imbalance_threshold: u32,
    /// Max replica lag time
    #[prost(uint32, tag = "25")]
    pub replica_lag_time_max_ms: u32,
}
/// Broker-specific configuration
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BrokerConfiguration {
    /// Number of network threads
    #[prost(uint32, tag = "1")]
    pub num_network_threads: u32,
    /// Number of I/O threads
    #[prost(uint32, tag = "2")]
    pub num_io_threads: u32,
    /// Socket send buffer size
    #[prost(uint32, tag = "3")]
    pub socket_send_buffer_bytes: u32,
    /// Socket receive buffer size
    #[prost(uint32, tag = "4")]
    pub socket_receive_buffer_bytes: u32,
    /// Max socket request size
    #[prost(uint32, tag = "5")]
    pub socket_request_max_bytes: u32,
    /// Storage configurations
    ///
    /// Log directories
    #[prost(string, repeated, tag = "6")]
    pub log_dirs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Log segment size
    #[prost(uint32, tag = "7")]
    pub log_segment_bytes: u32,
    /// Log roll time
    #[prost(uint32, tag = "8")]
    pub log_roll_time_hours: u32,
    /// Log retention time
    #[prost(uint32, tag = "9")]
    pub log_retention_hours: u32,
    /// Log retention size
    #[prost(uint64, tag = "10")]
    pub log_retention_bytes: u64,
    /// Log cleanup interval
    #[prost(uint32, tag = "11")]
    pub log_cleanup_interval_ms: u32,
    /// Replication configurations
    ///
    /// Replica fetch max bytes
    #[prost(uint32, tag = "12")]
    pub replica_fetch_max_bytes: u32,
    /// Replica fetch wait max
    #[prost(uint32, tag = "13")]
    pub replica_fetch_wait_max_ms: u32,
    /// HWM checkpoint interval
    #[prost(uint32, tag = "14")]
    pub replica_high_watermark_checkpoint_interval_ms: u32,
    /// Number of replica fetchers
    #[prost(uint32, tag = "15")]
    pub num_replica_fetchers: u32,
}
/// Topic-specific configuration
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TopicConfiguration {
    /// Number of partitions
    #[prost(uint32, tag = "1")]
    pub partition_count: u32,
    /// Replication factor
    #[prost(uint32, tag = "2")]
    pub replication_factor: u32,
    /// Retention policy
    #[prost(message, optional, tag = "3")]
    pub retention_policy: ::core::option::Option<RetentionPolicy>,
    /// Compression type
    #[prost(enumeration = "CompressionType", tag = "4")]
    pub compression_type: i32,
    /// Cleanup policy: compact
    #[prost(bool, tag = "5")]
    pub cleanup_policy_compact: bool,
    /// Cleanup policy: delete
    #[prost(bool, tag = "6")]
    pub cleanup_policy_delete: bool,
    /// Segment configurations
    ///
    /// Segment size in bytes
    #[prost(uint32, tag = "7")]
    pub segment_bytes: u32,
    /// Segment time in ms
    #[prost(uint32, tag = "8")]
    pub segment_ms: u32,
    /// Segment jitter in ms
    #[prost(uint32, tag = "9")]
    pub segment_jitter_ms: u32,
    /// Segment index size
    #[prost(uint32, tag = "10")]
    pub segment_index_bytes: u32,
    /// Performance configurations
    ///
    /// Flush message count
    #[prost(uint32, tag = "11")]
    pub flush_messages: u32,
    /// Flush time interval
    #[prost(uint32, tag = "12")]
    pub flush_ms: u32,
    /// Min cleanable dirty ratio
    #[prost(uint32, tag = "13")]
    pub min_cleanable_dirty_ratio: u32,
    /// Delete retention time
    #[prost(uint32, tag = "14")]
    pub delete_retention_ms: u32,
    /// Min compaction lag
    #[prost(uint32, tag = "15")]
    pub min_compaction_lag_ms: u32,
    /// Max compaction lag
    #[prost(uint32, tag = "16")]
    pub max_compaction_lag_ms: u32,
    /// ETL and processing
    ///
    /// ETL processing modules
    #[prost(string, repeated, tag = "17")]
    pub etl_modules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Enable ETL processing
    #[prost(bool, tag = "18")]
    pub enable_etl_processing: bool,
}
/// Cluster health information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClusterHealth {
    /// Overall cluster health
    #[prost(enumeration = "HealthStatus", tag = "1")]
    pub overall_status: i32,
    /// Number of healthy brokers
    #[prost(uint32, tag = "2")]
    pub healthy_brokers: u32,
    /// Total number of brokers
    #[prost(uint32, tag = "3")]
    pub total_brokers: u32,
    /// Number of healthy partitions
    #[prost(uint32, tag = "4")]
    pub healthy_partitions: u32,
    /// Total number of partitions
    #[prost(uint32, tag = "5")]
    pub total_partitions: u32,
    /// Under-replicated partitions
    #[prost(uint32, tag = "6")]
    pub under_replicated_partitions: u32,
    /// Offline partitions
    #[prost(uint32, tag = "7")]
    pub offline_partitions: u32,
    /// Controller health
    ///
    /// Controller availability
    #[prost(bool, tag = "8")]
    pub controller_available: bool,
    /// Controller uptime
    #[prost(uint64, tag = "9")]
    pub controller_uptime_ms: u64,
    /// Controller failover count
    #[prost(uint32, tag = "10")]
    pub controller_failover_count: u32,
    /// Consensus health
    ///
    /// Consensus availability percentage
    #[prost(double, tag = "11")]
    pub consensus_availability: f64,
    /// Average consensus latency
    #[prost(double, tag = "12")]
    pub average_consensus_latency_ms: f64,
    /// Recent consensus failures
    #[prost(uint32, tag = "13")]
    pub consensus_failures: u32,
    /// Performance indicators
    ///
    /// Average cluster CPU usage
    #[prost(double, tag = "14")]
    pub cluster_cpu_usage: f64,
    /// Average cluster memory usage
    #[prost(double, tag = "15")]
    pub cluster_memory_usage: f64,
    /// Average cluster disk usage
    #[prost(double, tag = "16")]
    pub cluster_disk_usage: f64,
    /// Average cluster network usage
    #[prost(double, tag = "17")]
    pub cluster_network_usage: f64,
    /// Active issues and alerts
    ///
    /// Current health issues
    #[prost(message, repeated, tag = "18")]
    pub issues: ::prost::alloc::vec::Vec<HealthIssue>,
    /// Active health alerts
    #[prost(message, repeated, tag = "19")]
    pub alerts: ::prost::alloc::vec::Vec<HealthAlert>,
}
/// Individual health issue
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthIssue {
    /// Unique issue ID
    #[prost(string, tag = "1")]
    pub issue_id: ::prost::alloc::string::String,
    /// Issue severity
    #[prost(enumeration = "HealthSeverity", tag = "2")]
    pub severity: i32,
    /// Affected component
    #[prost(string, tag = "3")]
    pub component: ::prost::alloc::string::String,
    /// Issue description
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    /// Detection timestamp
    #[prost(message, optional, tag = "5")]
    pub detected_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Affected resources
    #[prost(string, repeated, tag = "6")]
    pub affected_resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Recommended action
    #[prost(string, tag = "7")]
    pub recommended_action: ::prost::alloc::string::String,
    /// Whether auto-resolvable
    #[prost(bool, tag = "8")]
    pub auto_resolvable: bool,
}
/// Health alert information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthAlert {
    /// Unique alert ID
    #[prost(string, tag = "1")]
    pub alert_id: ::prost::alloc::string::String,
    /// Alert type
    #[prost(enumeration = "AlertType", tag = "2")]
    pub r#type: i32,
    /// Alert severity
    #[prost(enumeration = "HealthSeverity", tag = "3")]
    pub severity: i32,
    /// Alert title
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    /// Alert message
    #[prost(string, tag = "5")]
    pub message: ::prost::alloc::string::String,
    /// Alert trigger time
    #[prost(message, optional, tag = "6")]
    pub triggered_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Alert tags
    #[prost(string, repeated, tag = "7")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Alert status
    #[prost(enumeration = "AlertStatus", tag = "8")]
    pub status: i32,
}
/// Ongoing operation tracking
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OngoingOperation {
    /// Unique operation ID
    #[prost(string, tag = "1")]
    pub operation_id: ::prost::alloc::string::String,
    /// Operation type
    #[prost(enumeration = "OperationType", tag = "2")]
    pub r#type: i32,
    /// Operation status
    #[prost(enumeration = "OperationStatus", tag = "3")]
    pub status: i32,
    /// Start timestamp
    #[prost(message, optional, tag = "4")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Estimated completion
    #[prost(message, optional, tag = "5")]
    pub estimated_completion: ::core::option::Option<::prost_types::Timestamp>,
    /// Progress percentage
    #[prost(double, tag = "6")]
    pub progress_percentage: f64,
    /// Operation description
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    /// Affected resources
    #[prost(string, repeated, tag = "8")]
    pub affected_resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Who initiated the operation
    #[prost(string, tag = "9")]
    pub initiated_by: ::prost::alloc::string::String,
    /// Operation details
    ///
    /// Operation-specific details
    #[prost(message, optional, tag = "10")]
    pub details: ::core::option::Option<OperationDetails>,
    /// Operation steps
    #[prost(message, repeated, tag = "11")]
    pub steps: ::prost::alloc::vec::Vec<OperationStep>,
}
/// Operation-specific details
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationDetails {
    /// Scale operation details
    #[prost(message, optional, tag = "1")]
    pub scale_details: ::core::option::Option<ScaleOperationDetails>,
    /// Rebalance operation details
    #[prost(message, optional, tag = "2")]
    pub rebalance_details: ::core::option::Option<RebalanceOperationDetails>,
    /// Upgrade operation details
    #[prost(message, optional, tag = "3")]
    pub upgrade_details: ::core::option::Option<UpgradeOperationDetails>,
    /// Maintenance operation details
    #[prost(message, optional, tag = "4")]
    pub maintenance_details: ::core::option::Option<MaintenanceOperationDetails>,
}
/// Scale operation details
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScaleOperationDetails {
    /// Target broker count
    #[prost(uint32, tag = "1")]
    pub target_broker_count: u32,
    /// Current broker count
    #[prost(uint32, tag = "2")]
    pub current_broker_count: u32,
    /// New broker IDs
    #[prost(string, repeated, tag = "3")]
    pub new_brokers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Removing broker IDs
    #[prost(string, repeated, tag = "4")]
    pub removing_brokers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Partition reassignment plan
    #[prost(message, optional, tag = "5")]
    pub reassignment: ::core::option::Option<PartitionReassignment>,
}
/// Rebalance operation details
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RebalanceOperationDetails {
    /// Partitions to move
    #[prost(uint32, tag = "1")]
    pub partitions_to_move: u32,
    /// Partitions moved
    #[prost(uint32, tag = "2")]
    pub partitions_moved: u32,
    /// Data to transfer
    #[prost(uint64, tag = "3")]
    pub data_to_transfer_bytes: u64,
    /// Data transferred
    #[prost(uint64, tag = "4")]
    pub data_transferred_bytes: u64,
    /// Individual partition moves
    #[prost(message, repeated, tag = "5")]
    pub partition_moves: ::prost::alloc::vec::Vec<PartitionMove>,
}
/// Upgrade operation details
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpgradeOperationDetails {
    /// Source version
    #[prost(string, tag = "1")]
    pub from_version: ::prost::alloc::string::String,
    /// Target version
    #[prost(string, tag = "2")]
    pub to_version: ::prost::alloc::string::String,
    /// Brokers upgraded
    #[prost(uint32, tag = "3")]
    pub brokers_upgraded: u32,
    /// Total brokers
    #[prost(uint32, tag = "4")]
    pub total_brokers: u32,
    /// Pending upgrade brokers
    #[prost(string, repeated, tag = "5")]
    pub pending_brokers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Failed upgrade brokers
    #[prost(string, repeated, tag = "6")]
    pub failed_brokers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Maintenance operation details
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaintenanceOperationDetails {
    /// Type of maintenance
    #[prost(enumeration = "MaintenanceType", tag = "1")]
    pub maintenance_type: i32,
    /// Affected brokers
    #[prost(string, repeated, tag = "2")]
    pub affected_brokers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Maintenance window
    #[prost(string, tag = "3")]
    pub maintenance_window: ::prost::alloc::string::String,
    /// Allow data loss flag
    #[prost(bool, tag = "4")]
    pub allow_data_loss: bool,
}
/// Individual operation step
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationStep {
    /// Step ID
    #[prost(string, tag = "1")]
    pub step_id: ::prost::alloc::string::String,
    /// Step name
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// Step status
    #[prost(enumeration = "OperationStatus", tag = "3")]
    pub status: i32,
    /// Step start time
    #[prost(message, optional, tag = "4")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Step completion time
    #[prost(message, optional, tag = "5")]
    pub completed_at: ::core::option::Option<::prost_types::Timestamp>,
    /// Step description
    #[prost(string, tag = "6")]
    pub description: ::prost::alloc::string::String,
    /// Error message (if failed)
    #[prost(string, tag = "7")]
    pub error_message: ::prost::alloc::string::String,
}
/// Partition move information
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionMove {
    /// Partition being moved
    #[prost(message, optional, tag = "1")]
    pub partition: ::core::option::Option<TopicPartition>,
    /// Source broker
    #[prost(string, tag = "2")]
    pub from_broker: ::prost::alloc::string::String,
    /// Destination broker
    #[prost(string, tag = "3")]
    pub to_broker: ::prost::alloc::string::String,
    /// Move status
    #[prost(enumeration = "OperationStatus", tag = "4")]
    pub status: i32,
    /// Bytes transferred
    #[prost(uint64, tag = "5")]
    pub bytes_transferred: u64,
    /// Total bytes to transfer
    #[prost(uint64, tag = "6")]
    pub total_bytes: u64,
    /// Move start time
    #[prost(message, optional, tag = "7")]
    pub started_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Partition reassignment plan
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionReassignment {
    /// Individual assignments
    #[prost(message, repeated, tag = "1")]
    pub assignments: ::prost::alloc::vec::Vec<PartitionAssignment>,
    /// Total data to move
    #[prost(uint64, tag = "2")]
    pub total_data_bytes: u64,
    /// Estimated time
    #[prost(uint32, tag = "3")]
    pub estimated_time_minutes: u32,
}
/// Individual partition assignment
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionAssignment {
    /// Partition
    #[prost(message, optional, tag = "1")]
    pub partition: ::core::option::Option<TopicPartition>,
    /// Current replicas
    #[prost(string, repeated, tag = "2")]
    pub current_replicas: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Target replicas
    #[prost(string, repeated, tag = "3")]
    pub target_replicas: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Assignment status
    #[prost(enumeration = "AssignmentStatus", tag = "4")]
    pub status: i32,
}
/// Placeholder messages for missing types
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClusterCapacity {
    #[prost(uint64, tag = "1")]
    pub total_storage_bytes: u64,
    #[prost(uint64, tag = "2")]
    pub available_storage_bytes: u64,
    #[prost(uint32, tag = "3")]
    pub total_cpu_cores: u32,
    #[prost(uint64, tag = "4")]
    pub total_memory_bytes: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClusterPerformance {
    #[prost(uint64, tag = "1")]
    pub messages_per_second: u64,
    #[prost(uint64, tag = "2")]
    pub bytes_per_second: u64,
    #[prost(double, tag = "3")]
    pub average_latency_ms: f64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrokerHealth {
    #[prost(enumeration = "HealthStatus", tag = "1")]
    pub status: i32,
    #[prost(double, tag = "2")]
    pub cpu_usage: f64,
    #[prost(double, tag = "3")]
    pub memory_usage: f64,
    #[prost(uint64, tag = "4")]
    pub disk_usage_bytes: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrokerResources {
    #[prost(uint32, tag = "1")]
    pub cpu_cores: u32,
    #[prost(uint64, tag = "2")]
    pub memory_bytes: u64,
    #[prost(uint64, tag = "3")]
    pub disk_bytes: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrokerPerformance {
    #[prost(uint64, tag = "1")]
    pub messages_per_second: u64,
    #[prost(uint64, tag = "2")]
    pub bytes_per_second: u64,
    #[prost(double, tag = "3")]
    pub cpu_usage: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpoint {
    #[prost(string, tag = "1")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub host: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub port: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NetworkHealth {
    #[prost(enumeration = "HealthStatus", tag = "1")]
    pub status: i32,
    #[prost(double, tag = "2")]
    pub latency_ms: f64,
    #[prost(uint64, tag = "3")]
    pub bandwidth_bps: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartitionDistribution {
    #[prost(string, tag = "1")]
    pub strategy: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub rack_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TopicPerformance {
    #[prost(uint64, tag = "1")]
    pub messages_per_second: u64,
    #[prost(uint64, tag = "2")]
    pub bytes_per_second: u64,
    #[prost(double, tag = "3")]
    pub write_latency_ms: f64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TopicUsage {
    #[prost(uint64, tag = "1")]
    pub total_messages: u64,
    #[prost(uint64, tag = "2")]
    pub total_bytes: u64,
    #[prost(uint32, tag = "3")]
    pub active_producers: u32,
    #[prost(uint32, tag = "4")]
    pub active_consumers: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataRetention {
    #[prost(uint64, tag = "1")]
    pub retention_ms: u64,
    #[prost(uint64, tag = "2")]
    pub retention_bytes: u64,
    #[prost(string, tag = "3")]
    pub policy: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataCompaction {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    #[prost(uint64, tag = "2")]
    pub last_compaction_time: u64,
    #[prost(string, tag = "3")]
    pub status: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessControl {
    #[prost(string, tag = "1")]
    pub principal: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub permission: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncryptionStatus {
    #[prost(bool, tag = "1")]
    pub enabled: bool,
    #[prost(string, tag = "2")]
    pub algorithm: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub key_version: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PartitionHealth {
    #[prost(enumeration = "HealthStatus", tag = "1")]
    pub status: i32,
    #[prost(bool, tag = "2")]
    pub leader_available: bool,
    #[prost(uint32, tag = "3")]
    pub in_sync_replica_count: u32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PartitionPerformance {
    #[prost(uint64, tag = "1")]
    pub messages_per_second: u64,
    #[prost(uint64, tag = "2")]
    pub bytes_per_second: u64,
    #[prost(double, tag = "3")]
    pub replication_lag_ms: f64,
}
/// Replica role enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReplicaRole {
    Unknown = 0,
    /// Leader replica
    Leader = 1,
    /// Follower replica
    Follower = 2,
    /// Observer replica (non-voting)
    Observer = 3,
}
impl ReplicaRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "REPLICA_ROLE_UNKNOWN",
            Self::Leader => "REPLICA_ROLE_LEADER",
            Self::Follower => "REPLICA_ROLE_FOLLOWER",
            Self::Observer => "REPLICA_ROLE_OBSERVER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPLICA_ROLE_UNKNOWN" => Some(Self::Unknown),
            "REPLICA_ROLE_LEADER" => Some(Self::Leader),
            "REPLICA_ROLE_FOLLOWER" => Some(Self::Follower),
            "REPLICA_ROLE_OBSERVER" => Some(Self::Observer),
            _ => None,
        }
    }
}
/// Replica status enumeration
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReplicaStatus {
    Unknown = 0,
    /// Replica is in sync
    InSync = 1,
    /// Replica is out of sync
    OutOfSync = 2,
    /// Replica is catching up
    CatchingUp = 3,
    /// Replica is offline
    Offline = 4,
    /// Replica has failed
    Failed = 5,
}
impl ReplicaStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "REPLICA_STATUS_UNKNOWN",
            Self::InSync => "REPLICA_STATUS_IN_SYNC",
            Self::OutOfSync => "REPLICA_STATUS_OUT_OF_SYNC",
            Self::CatchingUp => "REPLICA_STATUS_CATCHING_UP",
            Self::Offline => "REPLICA_STATUS_OFFLINE",
            Self::Failed => "REPLICA_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REPLICA_STATUS_UNKNOWN" => Some(Self::Unknown),
            "REPLICA_STATUS_IN_SYNC" => Some(Self::InSync),
            "REPLICA_STATUS_OUT_OF_SYNC" => Some(Self::OutOfSync),
            "REPLICA_STATUS_CATCHING_UP" => Some(Self::CatchingUp),
            "REPLICA_STATUS_OFFLINE" => Some(Self::Offline),
            "REPLICA_STATUS_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// Health severity levels
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthSeverity {
    Unknown = 0,
    /// Informational
    Info = 1,
    /// Warning
    Warning = 2,
    /// Critical
    Critical = 3,
    /// Emergency
    Emergency = 4,
}
impl HealthSeverity {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "HEALTH_SEVERITY_UNKNOWN",
            Self::Info => "HEALTH_SEVERITY_INFO",
            Self::Warning => "HEALTH_SEVERITY_WARNING",
            Self::Critical => "HEALTH_SEVERITY_CRITICAL",
            Self::Emergency => "HEALTH_SEVERITY_EMERGENCY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_SEVERITY_UNKNOWN" => Some(Self::Unknown),
            "HEALTH_SEVERITY_INFO" => Some(Self::Info),
            "HEALTH_SEVERITY_WARNING" => Some(Self::Warning),
            "HEALTH_SEVERITY_CRITICAL" => Some(Self::Critical),
            "HEALTH_SEVERITY_EMERGENCY" => Some(Self::Emergency),
            _ => None,
        }
    }
}
/// Alert types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlertType {
    Unknown = 0,
    /// Performance alert
    Performance = 1,
    /// Capacity alert
    Capacity = 2,
    /// Availability alert
    Availability = 3,
    /// Security alert
    Security = 4,
    /// Configuration alert
    Configuration = 5,
}
impl AlertType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ALERT_TYPE_UNKNOWN",
            Self::Performance => "ALERT_TYPE_PERFORMANCE",
            Self::Capacity => "ALERT_TYPE_CAPACITY",
            Self::Availability => "ALERT_TYPE_AVAILABILITY",
            Self::Security => "ALERT_TYPE_SECURITY",
            Self::Configuration => "ALERT_TYPE_CONFIGURATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALERT_TYPE_UNKNOWN" => Some(Self::Unknown),
            "ALERT_TYPE_PERFORMANCE" => Some(Self::Performance),
            "ALERT_TYPE_CAPACITY" => Some(Self::Capacity),
            "ALERT_TYPE_AVAILABILITY" => Some(Self::Availability),
            "ALERT_TYPE_SECURITY" => Some(Self::Security),
            "ALERT_TYPE_CONFIGURATION" => Some(Self::Configuration),
            _ => None,
        }
    }
}
/// Alert status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AlertStatus {
    Unknown = 0,
    /// Alert is active
    Active = 1,
    /// Alert acknowledged
    Acknowledged = 2,
    /// Alert resolved
    Resolved = 3,
    /// Alert suppressed
    Suppressed = 4,
}
impl AlertStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ALERT_STATUS_UNKNOWN",
            Self::Active => "ALERT_STATUS_ACTIVE",
            Self::Acknowledged => "ALERT_STATUS_ACKNOWLEDGED",
            Self::Resolved => "ALERT_STATUS_RESOLVED",
            Self::Suppressed => "ALERT_STATUS_SUPPRESSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ALERT_STATUS_UNKNOWN" => Some(Self::Unknown),
            "ALERT_STATUS_ACTIVE" => Some(Self::Active),
            "ALERT_STATUS_ACKNOWLEDGED" => Some(Self::Acknowledged),
            "ALERT_STATUS_RESOLVED" => Some(Self::Resolved),
            "ALERT_STATUS_SUPPRESSED" => Some(Self::Suppressed),
            _ => None,
        }
    }
}
/// Operation types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationType {
    Unknown = 0,
    /// Scale out operation
    ScaleOut = 1,
    /// Scale in operation
    ScaleIn = 2,
    /// Partition rebalance
    Rebalance = 3,
    /// Rolling upgrade
    Upgrade = 4,
    /// Maintenance operation
    Maintenance = 5,
    /// Backup operation
    Backup = 6,
    /// Restore operation
    Restore = 7,
    /// Data migration
    Migration = 8,
    /// Log compaction
    Compaction = 9,
    /// Cleanup operation
    Cleanup = 10,
}
impl OperationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "OPERATION_TYPE_UNKNOWN",
            Self::ScaleOut => "OPERATION_TYPE_SCALE_OUT",
            Self::ScaleIn => "OPERATION_TYPE_SCALE_IN",
            Self::Rebalance => "OPERATION_TYPE_REBALANCE",
            Self::Upgrade => "OPERATION_TYPE_UPGRADE",
            Self::Maintenance => "OPERATION_TYPE_MAINTENANCE",
            Self::Backup => "OPERATION_TYPE_BACKUP",
            Self::Restore => "OPERATION_TYPE_RESTORE",
            Self::Migration => "OPERATION_TYPE_MIGRATION",
            Self::Compaction => "OPERATION_TYPE_COMPACTION",
            Self::Cleanup => "OPERATION_TYPE_CLEANUP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATION_TYPE_UNKNOWN" => Some(Self::Unknown),
            "OPERATION_TYPE_SCALE_OUT" => Some(Self::ScaleOut),
            "OPERATION_TYPE_SCALE_IN" => Some(Self::ScaleIn),
            "OPERATION_TYPE_REBALANCE" => Some(Self::Rebalance),
            "OPERATION_TYPE_UPGRADE" => Some(Self::Upgrade),
            "OPERATION_TYPE_MAINTENANCE" => Some(Self::Maintenance),
            "OPERATION_TYPE_BACKUP" => Some(Self::Backup),
            "OPERATION_TYPE_RESTORE" => Some(Self::Restore),
            "OPERATION_TYPE_MIGRATION" => Some(Self::Migration),
            "OPERATION_TYPE_COMPACTION" => Some(Self::Compaction),
            "OPERATION_TYPE_CLEANUP" => Some(Self::Cleanup),
            _ => None,
        }
    }
}
/// Operation status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OperationStatus {
    Unknown = 0,
    /// Operation pending
    Pending = 1,
    /// Operation in progress
    InProgress = 2,
    /// Operation completed
    Completed = 3,
    /// Operation failed
    Failed = 4,
    /// Operation cancelled
    Cancelled = 5,
    /// Operation paused
    Paused = 6,
}
impl OperationStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "OPERATION_STATUS_UNKNOWN",
            Self::Pending => "OPERATION_STATUS_PENDING",
            Self::InProgress => "OPERATION_STATUS_IN_PROGRESS",
            Self::Completed => "OPERATION_STATUS_COMPLETED",
            Self::Failed => "OPERATION_STATUS_FAILED",
            Self::Cancelled => "OPERATION_STATUS_CANCELLED",
            Self::Paused => "OPERATION_STATUS_PAUSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPERATION_STATUS_UNKNOWN" => Some(Self::Unknown),
            "OPERATION_STATUS_PENDING" => Some(Self::Pending),
            "OPERATION_STATUS_IN_PROGRESS" => Some(Self::InProgress),
            "OPERATION_STATUS_COMPLETED" => Some(Self::Completed),
            "OPERATION_STATUS_FAILED" => Some(Self::Failed),
            "OPERATION_STATUS_CANCELLED" => Some(Self::Cancelled),
            "OPERATION_STATUS_PAUSED" => Some(Self::Paused),
            _ => None,
        }
    }
}
/// Maintenance types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MaintenanceType {
    Unknown = 0,
    /// Broker restart
    Restart = 1,
    /// Repair operation
    Repair = 2,
    /// Update operation
    Update = 3,
    /// Cleanup operation
    Cleanup = 4,
}
impl MaintenanceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "MAINTENANCE_TYPE_UNKNOWN",
            Self::Restart => "MAINTENANCE_TYPE_RESTART",
            Self::Repair => "MAINTENANCE_TYPE_REPAIR",
            Self::Update => "MAINTENANCE_TYPE_UPDATE",
            Self::Cleanup => "MAINTENANCE_TYPE_CLEANUP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MAINTENANCE_TYPE_UNKNOWN" => Some(Self::Unknown),
            "MAINTENANCE_TYPE_RESTART" => Some(Self::Restart),
            "MAINTENANCE_TYPE_REPAIR" => Some(Self::Repair),
            "MAINTENANCE_TYPE_UPDATE" => Some(Self::Update),
            "MAINTENANCE_TYPE_CLEANUP" => Some(Self::Cleanup),
            _ => None,
        }
    }
}
/// Assignment status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AssignmentStatus {
    Unknown = 0,
    /// Assignment pending
    Pending = 1,
    /// Assignment in progress
    InProgress = 2,
    /// Assignment completed
    Completed = 3,
    /// Assignment failed
    Failed = 4,
}
impl AssignmentStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ASSIGNMENT_STATUS_UNKNOWN",
            Self::Pending => "ASSIGNMENT_STATUS_PENDING",
            Self::InProgress => "ASSIGNMENT_STATUS_IN_PROGRESS",
            Self::Completed => "ASSIGNMENT_STATUS_COMPLETED",
            Self::Failed => "ASSIGNMENT_STATUS_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ASSIGNMENT_STATUS_UNKNOWN" => Some(Self::Unknown),
            "ASSIGNMENT_STATUS_PENDING" => Some(Self::Pending),
            "ASSIGNMENT_STATUS_IN_PROGRESS" => Some(Self::InProgress),
            "ASSIGNMENT_STATUS_COMPLETED" => Some(Self::Completed),
            "ASSIGNMENT_STATUS_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// Health status for components
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HealthStatus {
    Unknown = 0,
    /// Component is healthy
    Healthy = 1,
    /// Component is degraded but functional
    Degraded = 2,
    /// Component is unhealthy
    Unhealthy = 3,
    /// Component is offline
    Offline = 4,
    /// Component is in maintenance mode
    Maintenance = 5,
}
impl HealthStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "HEALTH_STATUS_UNKNOWN",
            Self::Healthy => "HEALTH_STATUS_HEALTHY",
            Self::Degraded => "HEALTH_STATUS_DEGRADED",
            Self::Unhealthy => "HEALTH_STATUS_UNHEALTHY",
            Self::Offline => "HEALTH_STATUS_OFFLINE",
            Self::Maintenance => "HEALTH_STATUS_MAINTENANCE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HEALTH_STATUS_UNKNOWN" => Some(Self::Unknown),
            "HEALTH_STATUS_HEALTHY" => Some(Self::Healthy),
            "HEALTH_STATUS_DEGRADED" => Some(Self::Degraded),
            "HEALTH_STATUS_UNHEALTHY" => Some(Self::Unhealthy),
            "HEALTH_STATUS_OFFLINE" => Some(Self::Offline),
            "HEALTH_STATUS_MAINTENANCE" => Some(Self::Maintenance),
            _ => None,
        }
    }
}
/// Topic status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TopicStatus {
    Unknown = 0,
    Active = 1,
    Creating = 2,
    Deleting = 3,
    Offline = 4,
}
impl TopicStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "TOPIC_STATUS_UNKNOWN",
            Self::Active => "TOPIC_STATUS_ACTIVE",
            Self::Creating => "TOPIC_STATUS_CREATING",
            Self::Deleting => "TOPIC_STATUS_DELETING",
            Self::Offline => "TOPIC_STATUS_OFFLINE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TOPIC_STATUS_UNKNOWN" => Some(Self::Unknown),
            "TOPIC_STATUS_ACTIVE" => Some(Self::Active),
            "TOPIC_STATUS_CREATING" => Some(Self::Creating),
            "TOPIC_STATUS_DELETING" => Some(Self::Deleting),
            "TOPIC_STATUS_OFFLINE" => Some(Self::Offline),
            _ => None,
        }
    }
}
